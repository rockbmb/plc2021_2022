Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> Program
Rule 1     Program -> DeclBlock CommandBlock
Rule 2     DeclBlock -> DeclBegin Vars DeclEnd
Rule 3     Vars -> Vars Var
Rule 4     Vars -> Var
Rule 5     Var -> intvar
Rule 6     Var -> boolvar
Rule 7     Var -> stringvar
Rule 8     intvar -> IntDecl Name Decl Integer
Rule 9     intvar -> IntDecl Name
Rule 10    boolvar -> BoolDecl Name Decl Bool
Rule 11    boolvar -> BoolDecl Name
Rule 12    stringvar -> StringDecl Name Decl String
Rule 13    stringvar -> StringDecl Name
Rule 14    CommandBlock -> CommandBlock Command
Rule 15    CommandBlock -> Command
Rule 16    Command -> Assign
Rule 17    Assign -> Name ASSIGN ExpressionI
Rule 18    Assign -> Name ASSIGN ExpressionB
Rule 19    Assign -> Name ASSIGN String
Rule 20    Assign -> Name ASSIGN ReadString LPAREN RPAREN
Rule 21    PrintableElem -> Name
Rule 22    PrintableElem -> Integer
Rule 23    PrintableElem -> Bool
Rule 24    PrintableElem -> String
Rule 25    PrintableList -> PrintableList COMMA PrintableElem
Rule 26    PrintableList -> PrintableElem
Rule 27    Command -> WriteString LPAREN PrintableList RPAREN
Rule 28    ExpressionI -> ExpressionI PLUS TermI
Rule 29    ExpressionI -> ExpressionI MINUS TermI
Rule 30    ExpressionI -> TermI
Rule 31    TermI -> TermI TIMES factorI
Rule 32    TermI -> TermI DIVIDE factorI
Rule 33    TermI -> factorI
Rule 34    factorI -> Integer
Rule 35    factorI -> Name
Rule 36    factorI -> LPAREN ExpressionI RPAREN
Rule 37    ExpressionB -> Bool
Rule 38    ExpressionB -> ExpressionI
Rule 39    ExpressionB -> ExpressionB AND ExpressionB
Rule 40    ExpressionB -> ExpressionB OR ExpressionB
Rule 41    ExpressionB -> NOT LPAREN ExpressionB RPAREN
Rule 42    ExpressionB -> LPAREN ExpressionB RPAREN
Rule 43    ExpressionB -> ExpressionI LT ExpressionI
Rule 44    ExpressionB -> ExpressionI LE ExpressionI
Rule 45    ExpressionB -> ExpressionI GT ExpressionI
Rule 46    ExpressionB -> ExpressionI GE ExpressionI
Rule 47    ExpressionB -> ExpressionI EQ ExpressionI
Rule 48    ExpressionB -> ExpressionI NEQ ExpressionI
Rule 49    Command -> IfThenElse
Rule 50    IfThenElse -> If ExpressionB Then LBRACKET CommandBlock RBRACKET Else LBRACKET CommandBlock RBRACKET
Rule 51    Command -> WhileDo
Rule 52    WhileDo -> While ExpressionB LBRACKET CommandBlock RBRACKET

Terminals, with rules where they appear

AND                  : 39
ASSIGN               : 17 18 19 20
Bool                 : 10 23 37
BoolDecl             : 10 11
COMMA                : 25
DIVIDE               : 32
Decl                 : 8 10 12
DeclBegin            : 2
DeclEnd              : 2
EQ                   : 47
Else                 : 50
GE                   : 46
GT                   : 45
If                   : 50
IntDecl              : 8 9
Integer              : 8 22 34
LBRACKET             : 50 50 52
LE                   : 44
LPAREN               : 20 27 36 41 42
LT                   : 43
MINUS                : 29
NEQ                  : 48
NOT                  : 41
Name                 : 8 9 10 11 12 13 17 18 19 20 21 35
OR                   : 40
PLUS                 : 28
RBRACKET             : 50 50 52
RPAREN               : 20 27 36 41 42
ReadString           : 20
String               : 12 19 24
StringDecl           : 12 13
TIMES                : 31
Then                 : 50
While                : 52
WriteString          : 27
error                : 

Nonterminals, with rules where they appear

Assign               : 16
Command              : 14 15
CommandBlock         : 1 14 50 50 52
DeclBlock            : 1
ExpressionB          : 18 39 39 40 40 41 42 50 52
ExpressionI          : 17 28 29 36 38 43 43 44 44 45 45 46 46 47 47 48 48
IfThenElse           : 49
PrintableElem        : 25 26
PrintableList        : 25 27
Program              : 0
TermI                : 28 29 30 31 32
Var                  : 3 4
Vars                 : 2 3
WhileDo              : 51
boolvar              : 6
factorI              : 31 32 33
intvar               : 5
stringvar            : 7

Parsing method: LALR

state 0

    (0) S' -> . Program
    (1) Program -> . DeclBlock CommandBlock
    (2) DeclBlock -> . DeclBegin Vars DeclEnd

    DeclBegin       shift and go to state 3

    Program                        shift and go to state 1
    DeclBlock                      shift and go to state 2

state 1

    (0) S' -> Program .



state 2

    (1) Program -> DeclBlock . CommandBlock
    (14) CommandBlock -> . CommandBlock Command
    (15) CommandBlock -> . Command
    (16) Command -> . Assign
    (27) Command -> . WriteString LPAREN PrintableList RPAREN
    (49) Command -> . IfThenElse
    (51) Command -> . WhileDo
    (17) Assign -> . Name ASSIGN ExpressionI
    (18) Assign -> . Name ASSIGN ExpressionB
    (19) Assign -> . Name ASSIGN String
    (20) Assign -> . Name ASSIGN ReadString LPAREN RPAREN
    (50) IfThenElse -> . If ExpressionB Then LBRACKET CommandBlock RBRACKET Else LBRACKET CommandBlock RBRACKET
    (52) WhileDo -> . While ExpressionB LBRACKET CommandBlock RBRACKET

    WriteString     shift and go to state 7
    Name            shift and go to state 10
    If              shift and go to state 11
    While           shift and go to state 12

    CommandBlock                   shift and go to state 4
    Command                        shift and go to state 5
    Assign                         shift and go to state 6
    IfThenElse                     shift and go to state 8
    WhileDo                        shift and go to state 9

state 3

    (2) DeclBlock -> DeclBegin . Vars DeclEnd
    (3) Vars -> . Vars Var
    (4) Vars -> . Var
    (5) Var -> . intvar
    (6) Var -> . boolvar
    (7) Var -> . stringvar
    (8) intvar -> . IntDecl Name Decl Integer
    (9) intvar -> . IntDecl Name
    (10) boolvar -> . BoolDecl Name Decl Bool
    (11) boolvar -> . BoolDecl Name
    (12) stringvar -> . StringDecl Name Decl String
    (13) stringvar -> . StringDecl Name

    IntDecl         shift and go to state 18
    BoolDecl        shift and go to state 19
    StringDecl      shift and go to state 20

    Vars                           shift and go to state 13
    Var                            shift and go to state 14
    intvar                         shift and go to state 15
    boolvar                        shift and go to state 16
    stringvar                      shift and go to state 17

state 4

    (1) Program -> DeclBlock CommandBlock .
    (14) CommandBlock -> CommandBlock . Command
    (16) Command -> . Assign
    (27) Command -> . WriteString LPAREN PrintableList RPAREN
    (49) Command -> . IfThenElse
    (51) Command -> . WhileDo
    (17) Assign -> . Name ASSIGN ExpressionI
    (18) Assign -> . Name ASSIGN ExpressionB
    (19) Assign -> . Name ASSIGN String
    (20) Assign -> . Name ASSIGN ReadString LPAREN RPAREN
    (50) IfThenElse -> . If ExpressionB Then LBRACKET CommandBlock RBRACKET Else LBRACKET CommandBlock RBRACKET
    (52) WhileDo -> . While ExpressionB LBRACKET CommandBlock RBRACKET

    $end            reduce using rule 1 (Program -> DeclBlock CommandBlock .)
    WriteString     shift and go to state 7
    Name            shift and go to state 10
    If              shift and go to state 11
    While           shift and go to state 12

    Command                        shift and go to state 21
    Assign                         shift and go to state 6
    IfThenElse                     shift and go to state 8
    WhileDo                        shift and go to state 9

state 5

    (15) CommandBlock -> Command .

    WriteString     reduce using rule 15 (CommandBlock -> Command .)
    Name            reduce using rule 15 (CommandBlock -> Command .)
    If              reduce using rule 15 (CommandBlock -> Command .)
    While           reduce using rule 15 (CommandBlock -> Command .)
    $end            reduce using rule 15 (CommandBlock -> Command .)
    RBRACKET        reduce using rule 15 (CommandBlock -> Command .)


state 6

    (16) Command -> Assign .

    WriteString     reduce using rule 16 (Command -> Assign .)
    Name            reduce using rule 16 (Command -> Assign .)
    If              reduce using rule 16 (Command -> Assign .)
    While           reduce using rule 16 (Command -> Assign .)
    $end            reduce using rule 16 (Command -> Assign .)
    RBRACKET        reduce using rule 16 (Command -> Assign .)


state 7

    (27) Command -> WriteString . LPAREN PrintableList RPAREN

    LPAREN          shift and go to state 22


state 8

    (49) Command -> IfThenElse .

    WriteString     reduce using rule 49 (Command -> IfThenElse .)
    Name            reduce using rule 49 (Command -> IfThenElse .)
    If              reduce using rule 49 (Command -> IfThenElse .)
    While           reduce using rule 49 (Command -> IfThenElse .)
    $end            reduce using rule 49 (Command -> IfThenElse .)
    RBRACKET        reduce using rule 49 (Command -> IfThenElse .)


state 9

    (51) Command -> WhileDo .

    WriteString     reduce using rule 51 (Command -> WhileDo .)
    Name            reduce using rule 51 (Command -> WhileDo .)
    If              reduce using rule 51 (Command -> WhileDo .)
    While           reduce using rule 51 (Command -> WhileDo .)
    $end            reduce using rule 51 (Command -> WhileDo .)
    RBRACKET        reduce using rule 51 (Command -> WhileDo .)


state 10

    (17) Assign -> Name . ASSIGN ExpressionI
    (18) Assign -> Name . ASSIGN ExpressionB
    (19) Assign -> Name . ASSIGN String
    (20) Assign -> Name . ASSIGN ReadString LPAREN RPAREN

    ASSIGN          shift and go to state 23


state 11

    (50) IfThenElse -> If . ExpressionB Then LBRACKET CommandBlock RBRACKET Else LBRACKET CommandBlock RBRACKET
    (37) ExpressionB -> . Bool
    (38) ExpressionB -> . ExpressionI
    (39) ExpressionB -> . ExpressionB AND ExpressionB
    (40) ExpressionB -> . ExpressionB OR ExpressionB
    (41) ExpressionB -> . NOT LPAREN ExpressionB RPAREN
    (42) ExpressionB -> . LPAREN ExpressionB RPAREN
    (43) ExpressionB -> . ExpressionI LT ExpressionI
    (44) ExpressionB -> . ExpressionI LE ExpressionI
    (45) ExpressionB -> . ExpressionI GT ExpressionI
    (46) ExpressionB -> . ExpressionI GE ExpressionI
    (47) ExpressionB -> . ExpressionI EQ ExpressionI
    (48) ExpressionB -> . ExpressionI NEQ ExpressionI
    (28) ExpressionI -> . ExpressionI PLUS TermI
    (29) ExpressionI -> . ExpressionI MINUS TermI
    (30) ExpressionI -> . TermI
    (31) TermI -> . TermI TIMES factorI
    (32) TermI -> . TermI DIVIDE factorI
    (33) TermI -> . factorI
    (34) factorI -> . Integer
    (35) factorI -> . Name
    (36) factorI -> . LPAREN ExpressionI RPAREN

    Bool            shift and go to state 25
    NOT             shift and go to state 27
    LPAREN          shift and go to state 28
    Integer         shift and go to state 31
    Name            shift and go to state 32

    ExpressionB                    shift and go to state 24
    ExpressionI                    shift and go to state 26
    TermI                          shift and go to state 29
    factorI                        shift and go to state 30

state 12

    (52) WhileDo -> While . ExpressionB LBRACKET CommandBlock RBRACKET
    (37) ExpressionB -> . Bool
    (38) ExpressionB -> . ExpressionI
    (39) ExpressionB -> . ExpressionB AND ExpressionB
    (40) ExpressionB -> . ExpressionB OR ExpressionB
    (41) ExpressionB -> . NOT LPAREN ExpressionB RPAREN
    (42) ExpressionB -> . LPAREN ExpressionB RPAREN
    (43) ExpressionB -> . ExpressionI LT ExpressionI
    (44) ExpressionB -> . ExpressionI LE ExpressionI
    (45) ExpressionB -> . ExpressionI GT ExpressionI
    (46) ExpressionB -> . ExpressionI GE ExpressionI
    (47) ExpressionB -> . ExpressionI EQ ExpressionI
    (48) ExpressionB -> . ExpressionI NEQ ExpressionI
    (28) ExpressionI -> . ExpressionI PLUS TermI
    (29) ExpressionI -> . ExpressionI MINUS TermI
    (30) ExpressionI -> . TermI
    (31) TermI -> . TermI TIMES factorI
    (32) TermI -> . TermI DIVIDE factorI
    (33) TermI -> . factorI
    (34) factorI -> . Integer
    (35) factorI -> . Name
    (36) factorI -> . LPAREN ExpressionI RPAREN

    Bool            shift and go to state 25
    NOT             shift and go to state 27
    LPAREN          shift and go to state 28
    Integer         shift and go to state 31
    Name            shift and go to state 32

    ExpressionB                    shift and go to state 33
    ExpressionI                    shift and go to state 26
    TermI                          shift and go to state 29
    factorI                        shift and go to state 30

state 13

    (2) DeclBlock -> DeclBegin Vars . DeclEnd
    (3) Vars -> Vars . Var
    (5) Var -> . intvar
    (6) Var -> . boolvar
    (7) Var -> . stringvar
    (8) intvar -> . IntDecl Name Decl Integer
    (9) intvar -> . IntDecl Name
    (10) boolvar -> . BoolDecl Name Decl Bool
    (11) boolvar -> . BoolDecl Name
    (12) stringvar -> . StringDecl Name Decl String
    (13) stringvar -> . StringDecl Name

    DeclEnd         shift and go to state 34
    IntDecl         shift and go to state 18
    BoolDecl        shift and go to state 19
    StringDecl      shift and go to state 20

    Var                            shift and go to state 35
    intvar                         shift and go to state 15
    boolvar                        shift and go to state 16
    stringvar                      shift and go to state 17

state 14

    (4) Vars -> Var .

    DeclEnd         reduce using rule 4 (Vars -> Var .)
    IntDecl         reduce using rule 4 (Vars -> Var .)
    BoolDecl        reduce using rule 4 (Vars -> Var .)
    StringDecl      reduce using rule 4 (Vars -> Var .)


state 15

    (5) Var -> intvar .

    DeclEnd         reduce using rule 5 (Var -> intvar .)
    IntDecl         reduce using rule 5 (Var -> intvar .)
    BoolDecl        reduce using rule 5 (Var -> intvar .)
    StringDecl      reduce using rule 5 (Var -> intvar .)


state 16

    (6) Var -> boolvar .

    DeclEnd         reduce using rule 6 (Var -> boolvar .)
    IntDecl         reduce using rule 6 (Var -> boolvar .)
    BoolDecl        reduce using rule 6 (Var -> boolvar .)
    StringDecl      reduce using rule 6 (Var -> boolvar .)


state 17

    (7) Var -> stringvar .

    DeclEnd         reduce using rule 7 (Var -> stringvar .)
    IntDecl         reduce using rule 7 (Var -> stringvar .)
    BoolDecl        reduce using rule 7 (Var -> stringvar .)
    StringDecl      reduce using rule 7 (Var -> stringvar .)


state 18

    (8) intvar -> IntDecl . Name Decl Integer
    (9) intvar -> IntDecl . Name

    Name            shift and go to state 36


state 19

    (10) boolvar -> BoolDecl . Name Decl Bool
    (11) boolvar -> BoolDecl . Name

    Name            shift and go to state 37


state 20

    (12) stringvar -> StringDecl . Name Decl String
    (13) stringvar -> StringDecl . Name

    Name            shift and go to state 38


state 21

    (14) CommandBlock -> CommandBlock Command .

    WriteString     reduce using rule 14 (CommandBlock -> CommandBlock Command .)
    Name            reduce using rule 14 (CommandBlock -> CommandBlock Command .)
    If              reduce using rule 14 (CommandBlock -> CommandBlock Command .)
    While           reduce using rule 14 (CommandBlock -> CommandBlock Command .)
    $end            reduce using rule 14 (CommandBlock -> CommandBlock Command .)
    RBRACKET        reduce using rule 14 (CommandBlock -> CommandBlock Command .)


state 22

    (27) Command -> WriteString LPAREN . PrintableList RPAREN
    (25) PrintableList -> . PrintableList COMMA PrintableElem
    (26) PrintableList -> . PrintableElem
    (21) PrintableElem -> . Name
    (22) PrintableElem -> . Integer
    (23) PrintableElem -> . Bool
    (24) PrintableElem -> . String

    Name            shift and go to state 41
    Integer         shift and go to state 42
    Bool            shift and go to state 43
    String          shift and go to state 44

    PrintableList                  shift and go to state 39
    PrintableElem                  shift and go to state 40

state 23

    (17) Assign -> Name ASSIGN . ExpressionI
    (18) Assign -> Name ASSIGN . ExpressionB
    (19) Assign -> Name ASSIGN . String
    (20) Assign -> Name ASSIGN . ReadString LPAREN RPAREN
    (28) ExpressionI -> . ExpressionI PLUS TermI
    (29) ExpressionI -> . ExpressionI MINUS TermI
    (30) ExpressionI -> . TermI
    (37) ExpressionB -> . Bool
    (38) ExpressionB -> . ExpressionI
    (39) ExpressionB -> . ExpressionB AND ExpressionB
    (40) ExpressionB -> . ExpressionB OR ExpressionB
    (41) ExpressionB -> . NOT LPAREN ExpressionB RPAREN
    (42) ExpressionB -> . LPAREN ExpressionB RPAREN
    (43) ExpressionB -> . ExpressionI LT ExpressionI
    (44) ExpressionB -> . ExpressionI LE ExpressionI
    (45) ExpressionB -> . ExpressionI GT ExpressionI
    (46) ExpressionB -> . ExpressionI GE ExpressionI
    (47) ExpressionB -> . ExpressionI EQ ExpressionI
    (48) ExpressionB -> . ExpressionI NEQ ExpressionI
    (31) TermI -> . TermI TIMES factorI
    (32) TermI -> . TermI DIVIDE factorI
    (33) TermI -> . factorI
    (34) factorI -> . Integer
    (35) factorI -> . Name
    (36) factorI -> . LPAREN ExpressionI RPAREN

    String          shift and go to state 47
    ReadString      shift and go to state 48
    Bool            shift and go to state 25
    NOT             shift and go to state 27
    LPAREN          shift and go to state 28
    Integer         shift and go to state 31
    Name            shift and go to state 32

    ExpressionI                    shift and go to state 45
    ExpressionB                    shift and go to state 46
    TermI                          shift and go to state 29
    factorI                        shift and go to state 30

state 24

    (50) IfThenElse -> If ExpressionB . Then LBRACKET CommandBlock RBRACKET Else LBRACKET CommandBlock RBRACKET
    (39) ExpressionB -> ExpressionB . AND ExpressionB
    (40) ExpressionB -> ExpressionB . OR ExpressionB

    Then            shift and go to state 49
    AND             shift and go to state 50
    OR              shift and go to state 51


state 25

    (37) ExpressionB -> Bool .

    Then            reduce using rule 37 (ExpressionB -> Bool .)
    AND             reduce using rule 37 (ExpressionB -> Bool .)
    OR              reduce using rule 37 (ExpressionB -> Bool .)
    LBRACKET        reduce using rule 37 (ExpressionB -> Bool .)
    WriteString     reduce using rule 37 (ExpressionB -> Bool .)
    Name            reduce using rule 37 (ExpressionB -> Bool .)
    If              reduce using rule 37 (ExpressionB -> Bool .)
    While           reduce using rule 37 (ExpressionB -> Bool .)
    $end            reduce using rule 37 (ExpressionB -> Bool .)
    RBRACKET        reduce using rule 37 (ExpressionB -> Bool .)
    RPAREN          reduce using rule 37 (ExpressionB -> Bool .)


state 26

    (38) ExpressionB -> ExpressionI .
    (43) ExpressionB -> ExpressionI . LT ExpressionI
    (44) ExpressionB -> ExpressionI . LE ExpressionI
    (45) ExpressionB -> ExpressionI . GT ExpressionI
    (46) ExpressionB -> ExpressionI . GE ExpressionI
    (47) ExpressionB -> ExpressionI . EQ ExpressionI
    (48) ExpressionB -> ExpressionI . NEQ ExpressionI
    (28) ExpressionI -> ExpressionI . PLUS TermI
    (29) ExpressionI -> ExpressionI . MINUS TermI

    Then            reduce using rule 38 (ExpressionB -> ExpressionI .)
    AND             reduce using rule 38 (ExpressionB -> ExpressionI .)
    OR              reduce using rule 38 (ExpressionB -> ExpressionI .)
    LBRACKET        reduce using rule 38 (ExpressionB -> ExpressionI .)
    WriteString     reduce using rule 38 (ExpressionB -> ExpressionI .)
    Name            reduce using rule 38 (ExpressionB -> ExpressionI .)
    If              reduce using rule 38 (ExpressionB -> ExpressionI .)
    While           reduce using rule 38 (ExpressionB -> ExpressionI .)
    $end            reduce using rule 38 (ExpressionB -> ExpressionI .)
    RBRACKET        reduce using rule 38 (ExpressionB -> ExpressionI .)
    RPAREN          reduce using rule 38 (ExpressionB -> ExpressionI .)
    LT              shift and go to state 52
    LE              shift and go to state 53
    GT              shift and go to state 54
    GE              shift and go to state 55
    EQ              shift and go to state 56
    NEQ             shift and go to state 57
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59


state 27

    (41) ExpressionB -> NOT . LPAREN ExpressionB RPAREN

    LPAREN          shift and go to state 60


state 28

    (42) ExpressionB -> LPAREN . ExpressionB RPAREN
    (36) factorI -> LPAREN . ExpressionI RPAREN
    (37) ExpressionB -> . Bool
    (38) ExpressionB -> . ExpressionI
    (39) ExpressionB -> . ExpressionB AND ExpressionB
    (40) ExpressionB -> . ExpressionB OR ExpressionB
    (41) ExpressionB -> . NOT LPAREN ExpressionB RPAREN
    (42) ExpressionB -> . LPAREN ExpressionB RPAREN
    (43) ExpressionB -> . ExpressionI LT ExpressionI
    (44) ExpressionB -> . ExpressionI LE ExpressionI
    (45) ExpressionB -> . ExpressionI GT ExpressionI
    (46) ExpressionB -> . ExpressionI GE ExpressionI
    (47) ExpressionB -> . ExpressionI EQ ExpressionI
    (48) ExpressionB -> . ExpressionI NEQ ExpressionI
    (28) ExpressionI -> . ExpressionI PLUS TermI
    (29) ExpressionI -> . ExpressionI MINUS TermI
    (30) ExpressionI -> . TermI
    (31) TermI -> . TermI TIMES factorI
    (32) TermI -> . TermI DIVIDE factorI
    (33) TermI -> . factorI
    (34) factorI -> . Integer
    (35) factorI -> . Name
    (36) factorI -> . LPAREN ExpressionI RPAREN

    Bool            shift and go to state 25
    NOT             shift and go to state 27
    LPAREN          shift and go to state 28
    Integer         shift and go to state 31
    Name            shift and go to state 32

    ExpressionB                    shift and go to state 61
    ExpressionI                    shift and go to state 62
    TermI                          shift and go to state 29
    factorI                        shift and go to state 30

state 29

    (30) ExpressionI -> TermI .
    (31) TermI -> TermI . TIMES factorI
    (32) TermI -> TermI . DIVIDE factorI

    LT              reduce using rule 30 (ExpressionI -> TermI .)
    LE              reduce using rule 30 (ExpressionI -> TermI .)
    GT              reduce using rule 30 (ExpressionI -> TermI .)
    GE              reduce using rule 30 (ExpressionI -> TermI .)
    EQ              reduce using rule 30 (ExpressionI -> TermI .)
    NEQ             reduce using rule 30 (ExpressionI -> TermI .)
    PLUS            reduce using rule 30 (ExpressionI -> TermI .)
    MINUS           reduce using rule 30 (ExpressionI -> TermI .)
    Then            reduce using rule 30 (ExpressionI -> TermI .)
    AND             reduce using rule 30 (ExpressionI -> TermI .)
    OR              reduce using rule 30 (ExpressionI -> TermI .)
    LBRACKET        reduce using rule 30 (ExpressionI -> TermI .)
    WriteString     reduce using rule 30 (ExpressionI -> TermI .)
    Name            reduce using rule 30 (ExpressionI -> TermI .)
    If              reduce using rule 30 (ExpressionI -> TermI .)
    While           reduce using rule 30 (ExpressionI -> TermI .)
    $end            reduce using rule 30 (ExpressionI -> TermI .)
    RBRACKET        reduce using rule 30 (ExpressionI -> TermI .)
    RPAREN          reduce using rule 30 (ExpressionI -> TermI .)
    TIMES           shift and go to state 63
    DIVIDE          shift and go to state 64


state 30

    (33) TermI -> factorI .

    TIMES           reduce using rule 33 (TermI -> factorI .)
    DIVIDE          reduce using rule 33 (TermI -> factorI .)
    LT              reduce using rule 33 (TermI -> factorI .)
    LE              reduce using rule 33 (TermI -> factorI .)
    GT              reduce using rule 33 (TermI -> factorI .)
    GE              reduce using rule 33 (TermI -> factorI .)
    EQ              reduce using rule 33 (TermI -> factorI .)
    NEQ             reduce using rule 33 (TermI -> factorI .)
    PLUS            reduce using rule 33 (TermI -> factorI .)
    MINUS           reduce using rule 33 (TermI -> factorI .)
    Then            reduce using rule 33 (TermI -> factorI .)
    AND             reduce using rule 33 (TermI -> factorI .)
    OR              reduce using rule 33 (TermI -> factorI .)
    LBRACKET        reduce using rule 33 (TermI -> factorI .)
    WriteString     reduce using rule 33 (TermI -> factorI .)
    Name            reduce using rule 33 (TermI -> factorI .)
    If              reduce using rule 33 (TermI -> factorI .)
    While           reduce using rule 33 (TermI -> factorI .)
    $end            reduce using rule 33 (TermI -> factorI .)
    RBRACKET        reduce using rule 33 (TermI -> factorI .)
    RPAREN          reduce using rule 33 (TermI -> factorI .)


state 31

    (34) factorI -> Integer .

    TIMES           reduce using rule 34 (factorI -> Integer .)
    DIVIDE          reduce using rule 34 (factorI -> Integer .)
    LT              reduce using rule 34 (factorI -> Integer .)
    LE              reduce using rule 34 (factorI -> Integer .)
    GT              reduce using rule 34 (factorI -> Integer .)
    GE              reduce using rule 34 (factorI -> Integer .)
    EQ              reduce using rule 34 (factorI -> Integer .)
    NEQ             reduce using rule 34 (factorI -> Integer .)
    PLUS            reduce using rule 34 (factorI -> Integer .)
    MINUS           reduce using rule 34 (factorI -> Integer .)
    Then            reduce using rule 34 (factorI -> Integer .)
    AND             reduce using rule 34 (factorI -> Integer .)
    OR              reduce using rule 34 (factorI -> Integer .)
    LBRACKET        reduce using rule 34 (factorI -> Integer .)
    WriteString     reduce using rule 34 (factorI -> Integer .)
    Name            reduce using rule 34 (factorI -> Integer .)
    If              reduce using rule 34 (factorI -> Integer .)
    While           reduce using rule 34 (factorI -> Integer .)
    $end            reduce using rule 34 (factorI -> Integer .)
    RBRACKET        reduce using rule 34 (factorI -> Integer .)
    RPAREN          reduce using rule 34 (factorI -> Integer .)


state 32

    (35) factorI -> Name .

    TIMES           reduce using rule 35 (factorI -> Name .)
    DIVIDE          reduce using rule 35 (factorI -> Name .)
    LT              reduce using rule 35 (factorI -> Name .)
    LE              reduce using rule 35 (factorI -> Name .)
    GT              reduce using rule 35 (factorI -> Name .)
    GE              reduce using rule 35 (factorI -> Name .)
    EQ              reduce using rule 35 (factorI -> Name .)
    NEQ             reduce using rule 35 (factorI -> Name .)
    PLUS            reduce using rule 35 (factorI -> Name .)
    MINUS           reduce using rule 35 (factorI -> Name .)
    Then            reduce using rule 35 (factorI -> Name .)
    AND             reduce using rule 35 (factorI -> Name .)
    OR              reduce using rule 35 (factorI -> Name .)
    LBRACKET        reduce using rule 35 (factorI -> Name .)
    WriteString     reduce using rule 35 (factorI -> Name .)
    Name            reduce using rule 35 (factorI -> Name .)
    If              reduce using rule 35 (factorI -> Name .)
    While           reduce using rule 35 (factorI -> Name .)
    $end            reduce using rule 35 (factorI -> Name .)
    RBRACKET        reduce using rule 35 (factorI -> Name .)
    RPAREN          reduce using rule 35 (factorI -> Name .)


state 33

    (52) WhileDo -> While ExpressionB . LBRACKET CommandBlock RBRACKET
    (39) ExpressionB -> ExpressionB . AND ExpressionB
    (40) ExpressionB -> ExpressionB . OR ExpressionB

    LBRACKET        shift and go to state 65
    AND             shift and go to state 50
    OR              shift and go to state 51


state 34

    (2) DeclBlock -> DeclBegin Vars DeclEnd .

    WriteString     reduce using rule 2 (DeclBlock -> DeclBegin Vars DeclEnd .)
    Name            reduce using rule 2 (DeclBlock -> DeclBegin Vars DeclEnd .)
    If              reduce using rule 2 (DeclBlock -> DeclBegin Vars DeclEnd .)
    While           reduce using rule 2 (DeclBlock -> DeclBegin Vars DeclEnd .)


state 35

    (3) Vars -> Vars Var .

    DeclEnd         reduce using rule 3 (Vars -> Vars Var .)
    IntDecl         reduce using rule 3 (Vars -> Vars Var .)
    BoolDecl        reduce using rule 3 (Vars -> Vars Var .)
    StringDecl      reduce using rule 3 (Vars -> Vars Var .)


state 36

    (8) intvar -> IntDecl Name . Decl Integer
    (9) intvar -> IntDecl Name .

    Decl            shift and go to state 66
    DeclEnd         reduce using rule 9 (intvar -> IntDecl Name .)
    IntDecl         reduce using rule 9 (intvar -> IntDecl Name .)
    BoolDecl        reduce using rule 9 (intvar -> IntDecl Name .)
    StringDecl      reduce using rule 9 (intvar -> IntDecl Name .)


state 37

    (10) boolvar -> BoolDecl Name . Decl Bool
    (11) boolvar -> BoolDecl Name .

    Decl            shift and go to state 67
    DeclEnd         reduce using rule 11 (boolvar -> BoolDecl Name .)
    IntDecl         reduce using rule 11 (boolvar -> BoolDecl Name .)
    BoolDecl        reduce using rule 11 (boolvar -> BoolDecl Name .)
    StringDecl      reduce using rule 11 (boolvar -> BoolDecl Name .)


state 38

    (12) stringvar -> StringDecl Name . Decl String
    (13) stringvar -> StringDecl Name .

    Decl            shift and go to state 68
    DeclEnd         reduce using rule 13 (stringvar -> StringDecl Name .)
    IntDecl         reduce using rule 13 (stringvar -> StringDecl Name .)
    BoolDecl        reduce using rule 13 (stringvar -> StringDecl Name .)
    StringDecl      reduce using rule 13 (stringvar -> StringDecl Name .)


state 39

    (27) Command -> WriteString LPAREN PrintableList . RPAREN
    (25) PrintableList -> PrintableList . COMMA PrintableElem

    RPAREN          shift and go to state 69
    COMMA           shift and go to state 70


state 40

    (26) PrintableList -> PrintableElem .

    RPAREN          reduce using rule 26 (PrintableList -> PrintableElem .)
    COMMA           reduce using rule 26 (PrintableList -> PrintableElem .)


state 41

    (21) PrintableElem -> Name .

    RPAREN          reduce using rule 21 (PrintableElem -> Name .)
    COMMA           reduce using rule 21 (PrintableElem -> Name .)


state 42

    (22) PrintableElem -> Integer .

    RPAREN          reduce using rule 22 (PrintableElem -> Integer .)
    COMMA           reduce using rule 22 (PrintableElem -> Integer .)


state 43

    (23) PrintableElem -> Bool .

    RPAREN          reduce using rule 23 (PrintableElem -> Bool .)
    COMMA           reduce using rule 23 (PrintableElem -> Bool .)


state 44

    (24) PrintableElem -> String .

    RPAREN          reduce using rule 24 (PrintableElem -> String .)
    COMMA           reduce using rule 24 (PrintableElem -> String .)


state 45

    (17) Assign -> Name ASSIGN ExpressionI .
    (28) ExpressionI -> ExpressionI . PLUS TermI
    (29) ExpressionI -> ExpressionI . MINUS TermI
    (38) ExpressionB -> ExpressionI .
    (43) ExpressionB -> ExpressionI . LT ExpressionI
    (44) ExpressionB -> ExpressionI . LE ExpressionI
    (45) ExpressionB -> ExpressionI . GT ExpressionI
    (46) ExpressionB -> ExpressionI . GE ExpressionI
    (47) ExpressionB -> ExpressionI . EQ ExpressionI
    (48) ExpressionB -> ExpressionI . NEQ ExpressionI

  ! reduce/reduce conflict for WriteString resolved using rule 17 (Assign -> Name ASSIGN ExpressionI .)
  ! reduce/reduce conflict for Name resolved using rule 17 (Assign -> Name ASSIGN ExpressionI .)
  ! reduce/reduce conflict for If resolved using rule 17 (Assign -> Name ASSIGN ExpressionI .)
  ! reduce/reduce conflict for While resolved using rule 17 (Assign -> Name ASSIGN ExpressionI .)
  ! reduce/reduce conflict for $end resolved using rule 17 (Assign -> Name ASSIGN ExpressionI .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 17 (Assign -> Name ASSIGN ExpressionI .)
    WriteString     reduce using rule 17 (Assign -> Name ASSIGN ExpressionI .)
    Name            reduce using rule 17 (Assign -> Name ASSIGN ExpressionI .)
    If              reduce using rule 17 (Assign -> Name ASSIGN ExpressionI .)
    While           reduce using rule 17 (Assign -> Name ASSIGN ExpressionI .)
    $end            reduce using rule 17 (Assign -> Name ASSIGN ExpressionI .)
    RBRACKET        reduce using rule 17 (Assign -> Name ASSIGN ExpressionI .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    AND             reduce using rule 38 (ExpressionB -> ExpressionI .)
    OR              reduce using rule 38 (ExpressionB -> ExpressionI .)
    LT              shift and go to state 52
    LE              shift and go to state 53
    GT              shift and go to state 54
    GE              shift and go to state 55
    EQ              shift and go to state 56
    NEQ             shift and go to state 57

  ! WriteString     [ reduce using rule 38 (ExpressionB -> ExpressionI .) ]
  ! Name            [ reduce using rule 38 (ExpressionB -> ExpressionI .) ]
  ! If              [ reduce using rule 38 (ExpressionB -> ExpressionI .) ]
  ! While           [ reduce using rule 38 (ExpressionB -> ExpressionI .) ]
  ! $end            [ reduce using rule 38 (ExpressionB -> ExpressionI .) ]
  ! RBRACKET        [ reduce using rule 38 (ExpressionB -> ExpressionI .) ]


state 46

    (18) Assign -> Name ASSIGN ExpressionB .
    (39) ExpressionB -> ExpressionB . AND ExpressionB
    (40) ExpressionB -> ExpressionB . OR ExpressionB

    WriteString     reduce using rule 18 (Assign -> Name ASSIGN ExpressionB .)
    Name            reduce using rule 18 (Assign -> Name ASSIGN ExpressionB .)
    If              reduce using rule 18 (Assign -> Name ASSIGN ExpressionB .)
    While           reduce using rule 18 (Assign -> Name ASSIGN ExpressionB .)
    $end            reduce using rule 18 (Assign -> Name ASSIGN ExpressionB .)
    RBRACKET        reduce using rule 18 (Assign -> Name ASSIGN ExpressionB .)
    AND             shift and go to state 50
    OR              shift and go to state 51


state 47

    (19) Assign -> Name ASSIGN String .

    WriteString     reduce using rule 19 (Assign -> Name ASSIGN String .)
    Name            reduce using rule 19 (Assign -> Name ASSIGN String .)
    If              reduce using rule 19 (Assign -> Name ASSIGN String .)
    While           reduce using rule 19 (Assign -> Name ASSIGN String .)
    $end            reduce using rule 19 (Assign -> Name ASSIGN String .)
    RBRACKET        reduce using rule 19 (Assign -> Name ASSIGN String .)


state 48

    (20) Assign -> Name ASSIGN ReadString . LPAREN RPAREN

    LPAREN          shift and go to state 71


state 49

    (50) IfThenElse -> If ExpressionB Then . LBRACKET CommandBlock RBRACKET Else LBRACKET CommandBlock RBRACKET

    LBRACKET        shift and go to state 72


state 50

    (39) ExpressionB -> ExpressionB AND . ExpressionB
    (37) ExpressionB -> . Bool
    (38) ExpressionB -> . ExpressionI
    (39) ExpressionB -> . ExpressionB AND ExpressionB
    (40) ExpressionB -> . ExpressionB OR ExpressionB
    (41) ExpressionB -> . NOT LPAREN ExpressionB RPAREN
    (42) ExpressionB -> . LPAREN ExpressionB RPAREN
    (43) ExpressionB -> . ExpressionI LT ExpressionI
    (44) ExpressionB -> . ExpressionI LE ExpressionI
    (45) ExpressionB -> . ExpressionI GT ExpressionI
    (46) ExpressionB -> . ExpressionI GE ExpressionI
    (47) ExpressionB -> . ExpressionI EQ ExpressionI
    (48) ExpressionB -> . ExpressionI NEQ ExpressionI
    (28) ExpressionI -> . ExpressionI PLUS TermI
    (29) ExpressionI -> . ExpressionI MINUS TermI
    (30) ExpressionI -> . TermI
    (31) TermI -> . TermI TIMES factorI
    (32) TermI -> . TermI DIVIDE factorI
    (33) TermI -> . factorI
    (34) factorI -> . Integer
    (35) factorI -> . Name
    (36) factorI -> . LPAREN ExpressionI RPAREN

    Bool            shift and go to state 25
    NOT             shift and go to state 27
    LPAREN          shift and go to state 28
    Integer         shift and go to state 31
    Name            shift and go to state 32

    ExpressionB                    shift and go to state 73
    ExpressionI                    shift and go to state 26
    TermI                          shift and go to state 29
    factorI                        shift and go to state 30

state 51

    (40) ExpressionB -> ExpressionB OR . ExpressionB
    (37) ExpressionB -> . Bool
    (38) ExpressionB -> . ExpressionI
    (39) ExpressionB -> . ExpressionB AND ExpressionB
    (40) ExpressionB -> . ExpressionB OR ExpressionB
    (41) ExpressionB -> . NOT LPAREN ExpressionB RPAREN
    (42) ExpressionB -> . LPAREN ExpressionB RPAREN
    (43) ExpressionB -> . ExpressionI LT ExpressionI
    (44) ExpressionB -> . ExpressionI LE ExpressionI
    (45) ExpressionB -> . ExpressionI GT ExpressionI
    (46) ExpressionB -> . ExpressionI GE ExpressionI
    (47) ExpressionB -> . ExpressionI EQ ExpressionI
    (48) ExpressionB -> . ExpressionI NEQ ExpressionI
    (28) ExpressionI -> . ExpressionI PLUS TermI
    (29) ExpressionI -> . ExpressionI MINUS TermI
    (30) ExpressionI -> . TermI
    (31) TermI -> . TermI TIMES factorI
    (32) TermI -> . TermI DIVIDE factorI
    (33) TermI -> . factorI
    (34) factorI -> . Integer
    (35) factorI -> . Name
    (36) factorI -> . LPAREN ExpressionI RPAREN

    Bool            shift and go to state 25
    NOT             shift and go to state 27
    LPAREN          shift and go to state 28
    Integer         shift and go to state 31
    Name            shift and go to state 32

    ExpressionB                    shift and go to state 74
    ExpressionI                    shift and go to state 26
    TermI                          shift and go to state 29
    factorI                        shift and go to state 30

state 52

    (43) ExpressionB -> ExpressionI LT . ExpressionI
    (28) ExpressionI -> . ExpressionI PLUS TermI
    (29) ExpressionI -> . ExpressionI MINUS TermI
    (30) ExpressionI -> . TermI
    (31) TermI -> . TermI TIMES factorI
    (32) TermI -> . TermI DIVIDE factorI
    (33) TermI -> . factorI
    (34) factorI -> . Integer
    (35) factorI -> . Name
    (36) factorI -> . LPAREN ExpressionI RPAREN

    Integer         shift and go to state 31
    Name            shift and go to state 32
    LPAREN          shift and go to state 76

    ExpressionI                    shift and go to state 75
    TermI                          shift and go to state 29
    factorI                        shift and go to state 30

state 53

    (44) ExpressionB -> ExpressionI LE . ExpressionI
    (28) ExpressionI -> . ExpressionI PLUS TermI
    (29) ExpressionI -> . ExpressionI MINUS TermI
    (30) ExpressionI -> . TermI
    (31) TermI -> . TermI TIMES factorI
    (32) TermI -> . TermI DIVIDE factorI
    (33) TermI -> . factorI
    (34) factorI -> . Integer
    (35) factorI -> . Name
    (36) factorI -> . LPAREN ExpressionI RPAREN

    Integer         shift and go to state 31
    Name            shift and go to state 32
    LPAREN          shift and go to state 76

    ExpressionI                    shift and go to state 77
    TermI                          shift and go to state 29
    factorI                        shift and go to state 30

state 54

    (45) ExpressionB -> ExpressionI GT . ExpressionI
    (28) ExpressionI -> . ExpressionI PLUS TermI
    (29) ExpressionI -> . ExpressionI MINUS TermI
    (30) ExpressionI -> . TermI
    (31) TermI -> . TermI TIMES factorI
    (32) TermI -> . TermI DIVIDE factorI
    (33) TermI -> . factorI
    (34) factorI -> . Integer
    (35) factorI -> . Name
    (36) factorI -> . LPAREN ExpressionI RPAREN

    Integer         shift and go to state 31
    Name            shift and go to state 32
    LPAREN          shift and go to state 76

    ExpressionI                    shift and go to state 78
    TermI                          shift and go to state 29
    factorI                        shift and go to state 30

state 55

    (46) ExpressionB -> ExpressionI GE . ExpressionI
    (28) ExpressionI -> . ExpressionI PLUS TermI
    (29) ExpressionI -> . ExpressionI MINUS TermI
    (30) ExpressionI -> . TermI
    (31) TermI -> . TermI TIMES factorI
    (32) TermI -> . TermI DIVIDE factorI
    (33) TermI -> . factorI
    (34) factorI -> . Integer
    (35) factorI -> . Name
    (36) factorI -> . LPAREN ExpressionI RPAREN

    Integer         shift and go to state 31
    Name            shift and go to state 32
    LPAREN          shift and go to state 76

    ExpressionI                    shift and go to state 79
    TermI                          shift and go to state 29
    factorI                        shift and go to state 30

state 56

    (47) ExpressionB -> ExpressionI EQ . ExpressionI
    (28) ExpressionI -> . ExpressionI PLUS TermI
    (29) ExpressionI -> . ExpressionI MINUS TermI
    (30) ExpressionI -> . TermI
    (31) TermI -> . TermI TIMES factorI
    (32) TermI -> . TermI DIVIDE factorI
    (33) TermI -> . factorI
    (34) factorI -> . Integer
    (35) factorI -> . Name
    (36) factorI -> . LPAREN ExpressionI RPAREN

    Integer         shift and go to state 31
    Name            shift and go to state 32
    LPAREN          shift and go to state 76

    ExpressionI                    shift and go to state 80
    TermI                          shift and go to state 29
    factorI                        shift and go to state 30

state 57

    (48) ExpressionB -> ExpressionI NEQ . ExpressionI
    (28) ExpressionI -> . ExpressionI PLUS TermI
    (29) ExpressionI -> . ExpressionI MINUS TermI
    (30) ExpressionI -> . TermI
    (31) TermI -> . TermI TIMES factorI
    (32) TermI -> . TermI DIVIDE factorI
    (33) TermI -> . factorI
    (34) factorI -> . Integer
    (35) factorI -> . Name
    (36) factorI -> . LPAREN ExpressionI RPAREN

    Integer         shift and go to state 31
    Name            shift and go to state 32
    LPAREN          shift and go to state 76

    ExpressionI                    shift and go to state 81
    TermI                          shift and go to state 29
    factorI                        shift and go to state 30

state 58

    (28) ExpressionI -> ExpressionI PLUS . TermI
    (31) TermI -> . TermI TIMES factorI
    (32) TermI -> . TermI DIVIDE factorI
    (33) TermI -> . factorI
    (34) factorI -> . Integer
    (35) factorI -> . Name
    (36) factorI -> . LPAREN ExpressionI RPAREN

    Integer         shift and go to state 31
    Name            shift and go to state 32
    LPAREN          shift and go to state 76

    TermI                          shift and go to state 82
    factorI                        shift and go to state 30

state 59

    (29) ExpressionI -> ExpressionI MINUS . TermI
    (31) TermI -> . TermI TIMES factorI
    (32) TermI -> . TermI DIVIDE factorI
    (33) TermI -> . factorI
    (34) factorI -> . Integer
    (35) factorI -> . Name
    (36) factorI -> . LPAREN ExpressionI RPAREN

    Integer         shift and go to state 31
    Name            shift and go to state 32
    LPAREN          shift and go to state 76

    TermI                          shift and go to state 83
    factorI                        shift and go to state 30

state 60

    (41) ExpressionB -> NOT LPAREN . ExpressionB RPAREN
    (37) ExpressionB -> . Bool
    (38) ExpressionB -> . ExpressionI
    (39) ExpressionB -> . ExpressionB AND ExpressionB
    (40) ExpressionB -> . ExpressionB OR ExpressionB
    (41) ExpressionB -> . NOT LPAREN ExpressionB RPAREN
    (42) ExpressionB -> . LPAREN ExpressionB RPAREN
    (43) ExpressionB -> . ExpressionI LT ExpressionI
    (44) ExpressionB -> . ExpressionI LE ExpressionI
    (45) ExpressionB -> . ExpressionI GT ExpressionI
    (46) ExpressionB -> . ExpressionI GE ExpressionI
    (47) ExpressionB -> . ExpressionI EQ ExpressionI
    (48) ExpressionB -> . ExpressionI NEQ ExpressionI
    (28) ExpressionI -> . ExpressionI PLUS TermI
    (29) ExpressionI -> . ExpressionI MINUS TermI
    (30) ExpressionI -> . TermI
    (31) TermI -> . TermI TIMES factorI
    (32) TermI -> . TermI DIVIDE factorI
    (33) TermI -> . factorI
    (34) factorI -> . Integer
    (35) factorI -> . Name
    (36) factorI -> . LPAREN ExpressionI RPAREN

    Bool            shift and go to state 25
    NOT             shift and go to state 27
    LPAREN          shift and go to state 28
    Integer         shift and go to state 31
    Name            shift and go to state 32

    ExpressionB                    shift and go to state 84
    ExpressionI                    shift and go to state 26
    TermI                          shift and go to state 29
    factorI                        shift and go to state 30

state 61

    (42) ExpressionB -> LPAREN ExpressionB . RPAREN
    (39) ExpressionB -> ExpressionB . AND ExpressionB
    (40) ExpressionB -> ExpressionB . OR ExpressionB

    RPAREN          shift and go to state 85
    AND             shift and go to state 50
    OR              shift and go to state 51


state 62

    (36) factorI -> LPAREN ExpressionI . RPAREN
    (38) ExpressionB -> ExpressionI .
    (43) ExpressionB -> ExpressionI . LT ExpressionI
    (44) ExpressionB -> ExpressionI . LE ExpressionI
    (45) ExpressionB -> ExpressionI . GT ExpressionI
    (46) ExpressionB -> ExpressionI . GE ExpressionI
    (47) ExpressionB -> ExpressionI . EQ ExpressionI
    (48) ExpressionB -> ExpressionI . NEQ ExpressionI
    (28) ExpressionI -> ExpressionI . PLUS TermI
    (29) ExpressionI -> ExpressionI . MINUS TermI

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 86
    AND             reduce using rule 38 (ExpressionB -> ExpressionI .)
    OR              reduce using rule 38 (ExpressionB -> ExpressionI .)
    LT              shift and go to state 52
    LE              shift and go to state 53
    GT              shift and go to state 54
    GE              shift and go to state 55
    EQ              shift and go to state 56
    NEQ             shift and go to state 57
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59

  ! RPAREN          [ reduce using rule 38 (ExpressionB -> ExpressionI .) ]


state 63

    (31) TermI -> TermI TIMES . factorI
    (34) factorI -> . Integer
    (35) factorI -> . Name
    (36) factorI -> . LPAREN ExpressionI RPAREN

    Integer         shift and go to state 31
    Name            shift and go to state 32
    LPAREN          shift and go to state 76

    factorI                        shift and go to state 87

state 64

    (32) TermI -> TermI DIVIDE . factorI
    (34) factorI -> . Integer
    (35) factorI -> . Name
    (36) factorI -> . LPAREN ExpressionI RPAREN

    Integer         shift and go to state 31
    Name            shift and go to state 32
    LPAREN          shift and go to state 76

    factorI                        shift and go to state 88

state 65

    (52) WhileDo -> While ExpressionB LBRACKET . CommandBlock RBRACKET
    (14) CommandBlock -> . CommandBlock Command
    (15) CommandBlock -> . Command
    (16) Command -> . Assign
    (27) Command -> . WriteString LPAREN PrintableList RPAREN
    (49) Command -> . IfThenElse
    (51) Command -> . WhileDo
    (17) Assign -> . Name ASSIGN ExpressionI
    (18) Assign -> . Name ASSIGN ExpressionB
    (19) Assign -> . Name ASSIGN String
    (20) Assign -> . Name ASSIGN ReadString LPAREN RPAREN
    (50) IfThenElse -> . If ExpressionB Then LBRACKET CommandBlock RBRACKET Else LBRACKET CommandBlock RBRACKET
    (52) WhileDo -> . While ExpressionB LBRACKET CommandBlock RBRACKET

    WriteString     shift and go to state 7
    Name            shift and go to state 10
    If              shift and go to state 11
    While           shift and go to state 12

    CommandBlock                   shift and go to state 89
    Command                        shift and go to state 5
    Assign                         shift and go to state 6
    IfThenElse                     shift and go to state 8
    WhileDo                        shift and go to state 9

state 66

    (8) intvar -> IntDecl Name Decl . Integer

    Integer         shift and go to state 90


state 67

    (10) boolvar -> BoolDecl Name Decl . Bool

    Bool            shift and go to state 91


state 68

    (12) stringvar -> StringDecl Name Decl . String

    String          shift and go to state 92


state 69

    (27) Command -> WriteString LPAREN PrintableList RPAREN .

    WriteString     reduce using rule 27 (Command -> WriteString LPAREN PrintableList RPAREN .)
    Name            reduce using rule 27 (Command -> WriteString LPAREN PrintableList RPAREN .)
    If              reduce using rule 27 (Command -> WriteString LPAREN PrintableList RPAREN .)
    While           reduce using rule 27 (Command -> WriteString LPAREN PrintableList RPAREN .)
    $end            reduce using rule 27 (Command -> WriteString LPAREN PrintableList RPAREN .)
    RBRACKET        reduce using rule 27 (Command -> WriteString LPAREN PrintableList RPAREN .)


state 70

    (25) PrintableList -> PrintableList COMMA . PrintableElem
    (21) PrintableElem -> . Name
    (22) PrintableElem -> . Integer
    (23) PrintableElem -> . Bool
    (24) PrintableElem -> . String

    Name            shift and go to state 41
    Integer         shift and go to state 42
    Bool            shift and go to state 43
    String          shift and go to state 44

    PrintableElem                  shift and go to state 93

state 71

    (20) Assign -> Name ASSIGN ReadString LPAREN . RPAREN

    RPAREN          shift and go to state 94


state 72

    (50) IfThenElse -> If ExpressionB Then LBRACKET . CommandBlock RBRACKET Else LBRACKET CommandBlock RBRACKET
    (14) CommandBlock -> . CommandBlock Command
    (15) CommandBlock -> . Command
    (16) Command -> . Assign
    (27) Command -> . WriteString LPAREN PrintableList RPAREN
    (49) Command -> . IfThenElse
    (51) Command -> . WhileDo
    (17) Assign -> . Name ASSIGN ExpressionI
    (18) Assign -> . Name ASSIGN ExpressionB
    (19) Assign -> . Name ASSIGN String
    (20) Assign -> . Name ASSIGN ReadString LPAREN RPAREN
    (50) IfThenElse -> . If ExpressionB Then LBRACKET CommandBlock RBRACKET Else LBRACKET CommandBlock RBRACKET
    (52) WhileDo -> . While ExpressionB LBRACKET CommandBlock RBRACKET

    WriteString     shift and go to state 7
    Name            shift and go to state 10
    If              shift and go to state 11
    While           shift and go to state 12

    CommandBlock                   shift and go to state 95
    Command                        shift and go to state 5
    Assign                         shift and go to state 6
    IfThenElse                     shift and go to state 8
    WhileDo                        shift and go to state 9

state 73

    (39) ExpressionB -> ExpressionB AND ExpressionB .
    (39) ExpressionB -> ExpressionB . AND ExpressionB
    (40) ExpressionB -> ExpressionB . OR ExpressionB

    Then            reduce using rule 39 (ExpressionB -> ExpressionB AND ExpressionB .)
    AND             reduce using rule 39 (ExpressionB -> ExpressionB AND ExpressionB .)
    OR              reduce using rule 39 (ExpressionB -> ExpressionB AND ExpressionB .)
    LBRACKET        reduce using rule 39 (ExpressionB -> ExpressionB AND ExpressionB .)
    WriteString     reduce using rule 39 (ExpressionB -> ExpressionB AND ExpressionB .)
    Name            reduce using rule 39 (ExpressionB -> ExpressionB AND ExpressionB .)
    If              reduce using rule 39 (ExpressionB -> ExpressionB AND ExpressionB .)
    While           reduce using rule 39 (ExpressionB -> ExpressionB AND ExpressionB .)
    $end            reduce using rule 39 (ExpressionB -> ExpressionB AND ExpressionB .)
    RBRACKET        reduce using rule 39 (ExpressionB -> ExpressionB AND ExpressionB .)
    RPAREN          reduce using rule 39 (ExpressionB -> ExpressionB AND ExpressionB .)

  ! AND             [ shift and go to state 50 ]
  ! OR              [ shift and go to state 51 ]


state 74

    (40) ExpressionB -> ExpressionB OR ExpressionB .
    (39) ExpressionB -> ExpressionB . AND ExpressionB
    (40) ExpressionB -> ExpressionB . OR ExpressionB

    Then            reduce using rule 40 (ExpressionB -> ExpressionB OR ExpressionB .)
    OR              reduce using rule 40 (ExpressionB -> ExpressionB OR ExpressionB .)
    LBRACKET        reduce using rule 40 (ExpressionB -> ExpressionB OR ExpressionB .)
    WriteString     reduce using rule 40 (ExpressionB -> ExpressionB OR ExpressionB .)
    Name            reduce using rule 40 (ExpressionB -> ExpressionB OR ExpressionB .)
    If              reduce using rule 40 (ExpressionB -> ExpressionB OR ExpressionB .)
    While           reduce using rule 40 (ExpressionB -> ExpressionB OR ExpressionB .)
    $end            reduce using rule 40 (ExpressionB -> ExpressionB OR ExpressionB .)
    RBRACKET        reduce using rule 40 (ExpressionB -> ExpressionB OR ExpressionB .)
    RPAREN          reduce using rule 40 (ExpressionB -> ExpressionB OR ExpressionB .)
    AND             shift and go to state 50

  ! AND             [ reduce using rule 40 (ExpressionB -> ExpressionB OR ExpressionB .) ]
  ! OR              [ shift and go to state 51 ]


state 75

    (43) ExpressionB -> ExpressionI LT ExpressionI .
    (28) ExpressionI -> ExpressionI . PLUS TermI
    (29) ExpressionI -> ExpressionI . MINUS TermI

    Then            reduce using rule 43 (ExpressionB -> ExpressionI LT ExpressionI .)
    AND             reduce using rule 43 (ExpressionB -> ExpressionI LT ExpressionI .)
    OR              reduce using rule 43 (ExpressionB -> ExpressionI LT ExpressionI .)
    LBRACKET        reduce using rule 43 (ExpressionB -> ExpressionI LT ExpressionI .)
    WriteString     reduce using rule 43 (ExpressionB -> ExpressionI LT ExpressionI .)
    Name            reduce using rule 43 (ExpressionB -> ExpressionI LT ExpressionI .)
    If              reduce using rule 43 (ExpressionB -> ExpressionI LT ExpressionI .)
    While           reduce using rule 43 (ExpressionB -> ExpressionI LT ExpressionI .)
    $end            reduce using rule 43 (ExpressionB -> ExpressionI LT ExpressionI .)
    RBRACKET        reduce using rule 43 (ExpressionB -> ExpressionI LT ExpressionI .)
    RPAREN          reduce using rule 43 (ExpressionB -> ExpressionI LT ExpressionI .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59


state 76

    (36) factorI -> LPAREN . ExpressionI RPAREN
    (28) ExpressionI -> . ExpressionI PLUS TermI
    (29) ExpressionI -> . ExpressionI MINUS TermI
    (30) ExpressionI -> . TermI
    (31) TermI -> . TermI TIMES factorI
    (32) TermI -> . TermI DIVIDE factorI
    (33) TermI -> . factorI
    (34) factorI -> . Integer
    (35) factorI -> . Name
    (36) factorI -> . LPAREN ExpressionI RPAREN

    Integer         shift and go to state 31
    Name            shift and go to state 32
    LPAREN          shift and go to state 76

    ExpressionI                    shift and go to state 96
    TermI                          shift and go to state 29
    factorI                        shift and go to state 30

state 77

    (44) ExpressionB -> ExpressionI LE ExpressionI .
    (28) ExpressionI -> ExpressionI . PLUS TermI
    (29) ExpressionI -> ExpressionI . MINUS TermI

    Then            reduce using rule 44 (ExpressionB -> ExpressionI LE ExpressionI .)
    AND             reduce using rule 44 (ExpressionB -> ExpressionI LE ExpressionI .)
    OR              reduce using rule 44 (ExpressionB -> ExpressionI LE ExpressionI .)
    LBRACKET        reduce using rule 44 (ExpressionB -> ExpressionI LE ExpressionI .)
    WriteString     reduce using rule 44 (ExpressionB -> ExpressionI LE ExpressionI .)
    Name            reduce using rule 44 (ExpressionB -> ExpressionI LE ExpressionI .)
    If              reduce using rule 44 (ExpressionB -> ExpressionI LE ExpressionI .)
    While           reduce using rule 44 (ExpressionB -> ExpressionI LE ExpressionI .)
    $end            reduce using rule 44 (ExpressionB -> ExpressionI LE ExpressionI .)
    RBRACKET        reduce using rule 44 (ExpressionB -> ExpressionI LE ExpressionI .)
    RPAREN          reduce using rule 44 (ExpressionB -> ExpressionI LE ExpressionI .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59


state 78

    (45) ExpressionB -> ExpressionI GT ExpressionI .
    (28) ExpressionI -> ExpressionI . PLUS TermI
    (29) ExpressionI -> ExpressionI . MINUS TermI

    Then            reduce using rule 45 (ExpressionB -> ExpressionI GT ExpressionI .)
    AND             reduce using rule 45 (ExpressionB -> ExpressionI GT ExpressionI .)
    OR              reduce using rule 45 (ExpressionB -> ExpressionI GT ExpressionI .)
    LBRACKET        reduce using rule 45 (ExpressionB -> ExpressionI GT ExpressionI .)
    WriteString     reduce using rule 45 (ExpressionB -> ExpressionI GT ExpressionI .)
    Name            reduce using rule 45 (ExpressionB -> ExpressionI GT ExpressionI .)
    If              reduce using rule 45 (ExpressionB -> ExpressionI GT ExpressionI .)
    While           reduce using rule 45 (ExpressionB -> ExpressionI GT ExpressionI .)
    $end            reduce using rule 45 (ExpressionB -> ExpressionI GT ExpressionI .)
    RBRACKET        reduce using rule 45 (ExpressionB -> ExpressionI GT ExpressionI .)
    RPAREN          reduce using rule 45 (ExpressionB -> ExpressionI GT ExpressionI .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59


state 79

    (46) ExpressionB -> ExpressionI GE ExpressionI .
    (28) ExpressionI -> ExpressionI . PLUS TermI
    (29) ExpressionI -> ExpressionI . MINUS TermI

    Then            reduce using rule 46 (ExpressionB -> ExpressionI GE ExpressionI .)
    AND             reduce using rule 46 (ExpressionB -> ExpressionI GE ExpressionI .)
    OR              reduce using rule 46 (ExpressionB -> ExpressionI GE ExpressionI .)
    LBRACKET        reduce using rule 46 (ExpressionB -> ExpressionI GE ExpressionI .)
    WriteString     reduce using rule 46 (ExpressionB -> ExpressionI GE ExpressionI .)
    Name            reduce using rule 46 (ExpressionB -> ExpressionI GE ExpressionI .)
    If              reduce using rule 46 (ExpressionB -> ExpressionI GE ExpressionI .)
    While           reduce using rule 46 (ExpressionB -> ExpressionI GE ExpressionI .)
    $end            reduce using rule 46 (ExpressionB -> ExpressionI GE ExpressionI .)
    RBRACKET        reduce using rule 46 (ExpressionB -> ExpressionI GE ExpressionI .)
    RPAREN          reduce using rule 46 (ExpressionB -> ExpressionI GE ExpressionI .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59


state 80

    (47) ExpressionB -> ExpressionI EQ ExpressionI .
    (28) ExpressionI -> ExpressionI . PLUS TermI
    (29) ExpressionI -> ExpressionI . MINUS TermI

    Then            reduce using rule 47 (ExpressionB -> ExpressionI EQ ExpressionI .)
    AND             reduce using rule 47 (ExpressionB -> ExpressionI EQ ExpressionI .)
    OR              reduce using rule 47 (ExpressionB -> ExpressionI EQ ExpressionI .)
    LBRACKET        reduce using rule 47 (ExpressionB -> ExpressionI EQ ExpressionI .)
    WriteString     reduce using rule 47 (ExpressionB -> ExpressionI EQ ExpressionI .)
    Name            reduce using rule 47 (ExpressionB -> ExpressionI EQ ExpressionI .)
    If              reduce using rule 47 (ExpressionB -> ExpressionI EQ ExpressionI .)
    While           reduce using rule 47 (ExpressionB -> ExpressionI EQ ExpressionI .)
    $end            reduce using rule 47 (ExpressionB -> ExpressionI EQ ExpressionI .)
    RBRACKET        reduce using rule 47 (ExpressionB -> ExpressionI EQ ExpressionI .)
    RPAREN          reduce using rule 47 (ExpressionB -> ExpressionI EQ ExpressionI .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59


state 81

    (48) ExpressionB -> ExpressionI NEQ ExpressionI .
    (28) ExpressionI -> ExpressionI . PLUS TermI
    (29) ExpressionI -> ExpressionI . MINUS TermI

    Then            reduce using rule 48 (ExpressionB -> ExpressionI NEQ ExpressionI .)
    AND             reduce using rule 48 (ExpressionB -> ExpressionI NEQ ExpressionI .)
    OR              reduce using rule 48 (ExpressionB -> ExpressionI NEQ ExpressionI .)
    LBRACKET        reduce using rule 48 (ExpressionB -> ExpressionI NEQ ExpressionI .)
    WriteString     reduce using rule 48 (ExpressionB -> ExpressionI NEQ ExpressionI .)
    Name            reduce using rule 48 (ExpressionB -> ExpressionI NEQ ExpressionI .)
    If              reduce using rule 48 (ExpressionB -> ExpressionI NEQ ExpressionI .)
    While           reduce using rule 48 (ExpressionB -> ExpressionI NEQ ExpressionI .)
    $end            reduce using rule 48 (ExpressionB -> ExpressionI NEQ ExpressionI .)
    RBRACKET        reduce using rule 48 (ExpressionB -> ExpressionI NEQ ExpressionI .)
    RPAREN          reduce using rule 48 (ExpressionB -> ExpressionI NEQ ExpressionI .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59


state 82

    (28) ExpressionI -> ExpressionI PLUS TermI .
    (31) TermI -> TermI . TIMES factorI
    (32) TermI -> TermI . DIVIDE factorI

    LT              reduce using rule 28 (ExpressionI -> ExpressionI PLUS TermI .)
    LE              reduce using rule 28 (ExpressionI -> ExpressionI PLUS TermI .)
    GT              reduce using rule 28 (ExpressionI -> ExpressionI PLUS TermI .)
    GE              reduce using rule 28 (ExpressionI -> ExpressionI PLUS TermI .)
    EQ              reduce using rule 28 (ExpressionI -> ExpressionI PLUS TermI .)
    NEQ             reduce using rule 28 (ExpressionI -> ExpressionI PLUS TermI .)
    PLUS            reduce using rule 28 (ExpressionI -> ExpressionI PLUS TermI .)
    MINUS           reduce using rule 28 (ExpressionI -> ExpressionI PLUS TermI .)
    Then            reduce using rule 28 (ExpressionI -> ExpressionI PLUS TermI .)
    AND             reduce using rule 28 (ExpressionI -> ExpressionI PLUS TermI .)
    OR              reduce using rule 28 (ExpressionI -> ExpressionI PLUS TermI .)
    LBRACKET        reduce using rule 28 (ExpressionI -> ExpressionI PLUS TermI .)
    WriteString     reduce using rule 28 (ExpressionI -> ExpressionI PLUS TermI .)
    Name            reduce using rule 28 (ExpressionI -> ExpressionI PLUS TermI .)
    If              reduce using rule 28 (ExpressionI -> ExpressionI PLUS TermI .)
    While           reduce using rule 28 (ExpressionI -> ExpressionI PLUS TermI .)
    $end            reduce using rule 28 (ExpressionI -> ExpressionI PLUS TermI .)
    RBRACKET        reduce using rule 28 (ExpressionI -> ExpressionI PLUS TermI .)
    RPAREN          reduce using rule 28 (ExpressionI -> ExpressionI PLUS TermI .)
    TIMES           shift and go to state 63
    DIVIDE          shift and go to state 64


state 83

    (29) ExpressionI -> ExpressionI MINUS TermI .
    (31) TermI -> TermI . TIMES factorI
    (32) TermI -> TermI . DIVIDE factorI

    LT              reduce using rule 29 (ExpressionI -> ExpressionI MINUS TermI .)
    LE              reduce using rule 29 (ExpressionI -> ExpressionI MINUS TermI .)
    GT              reduce using rule 29 (ExpressionI -> ExpressionI MINUS TermI .)
    GE              reduce using rule 29 (ExpressionI -> ExpressionI MINUS TermI .)
    EQ              reduce using rule 29 (ExpressionI -> ExpressionI MINUS TermI .)
    NEQ             reduce using rule 29 (ExpressionI -> ExpressionI MINUS TermI .)
    PLUS            reduce using rule 29 (ExpressionI -> ExpressionI MINUS TermI .)
    MINUS           reduce using rule 29 (ExpressionI -> ExpressionI MINUS TermI .)
    Then            reduce using rule 29 (ExpressionI -> ExpressionI MINUS TermI .)
    AND             reduce using rule 29 (ExpressionI -> ExpressionI MINUS TermI .)
    OR              reduce using rule 29 (ExpressionI -> ExpressionI MINUS TermI .)
    LBRACKET        reduce using rule 29 (ExpressionI -> ExpressionI MINUS TermI .)
    WriteString     reduce using rule 29 (ExpressionI -> ExpressionI MINUS TermI .)
    Name            reduce using rule 29 (ExpressionI -> ExpressionI MINUS TermI .)
    If              reduce using rule 29 (ExpressionI -> ExpressionI MINUS TermI .)
    While           reduce using rule 29 (ExpressionI -> ExpressionI MINUS TermI .)
    $end            reduce using rule 29 (ExpressionI -> ExpressionI MINUS TermI .)
    RBRACKET        reduce using rule 29 (ExpressionI -> ExpressionI MINUS TermI .)
    RPAREN          reduce using rule 29 (ExpressionI -> ExpressionI MINUS TermI .)
    TIMES           shift and go to state 63
    DIVIDE          shift and go to state 64


state 84

    (41) ExpressionB -> NOT LPAREN ExpressionB . RPAREN
    (39) ExpressionB -> ExpressionB . AND ExpressionB
    (40) ExpressionB -> ExpressionB . OR ExpressionB

    RPAREN          shift and go to state 97
    AND             shift and go to state 50
    OR              shift and go to state 51


state 85

    (42) ExpressionB -> LPAREN ExpressionB RPAREN .

    Then            reduce using rule 42 (ExpressionB -> LPAREN ExpressionB RPAREN .)
    AND             reduce using rule 42 (ExpressionB -> LPAREN ExpressionB RPAREN .)
    OR              reduce using rule 42 (ExpressionB -> LPAREN ExpressionB RPAREN .)
    LBRACKET        reduce using rule 42 (ExpressionB -> LPAREN ExpressionB RPAREN .)
    WriteString     reduce using rule 42 (ExpressionB -> LPAREN ExpressionB RPAREN .)
    Name            reduce using rule 42 (ExpressionB -> LPAREN ExpressionB RPAREN .)
    If              reduce using rule 42 (ExpressionB -> LPAREN ExpressionB RPAREN .)
    While           reduce using rule 42 (ExpressionB -> LPAREN ExpressionB RPAREN .)
    $end            reduce using rule 42 (ExpressionB -> LPAREN ExpressionB RPAREN .)
    RBRACKET        reduce using rule 42 (ExpressionB -> LPAREN ExpressionB RPAREN .)
    RPAREN          reduce using rule 42 (ExpressionB -> LPAREN ExpressionB RPAREN .)


state 86

    (36) factorI -> LPAREN ExpressionI RPAREN .

    TIMES           reduce using rule 36 (factorI -> LPAREN ExpressionI RPAREN .)
    DIVIDE          reduce using rule 36 (factorI -> LPAREN ExpressionI RPAREN .)
    LT              reduce using rule 36 (factorI -> LPAREN ExpressionI RPAREN .)
    LE              reduce using rule 36 (factorI -> LPAREN ExpressionI RPAREN .)
    GT              reduce using rule 36 (factorI -> LPAREN ExpressionI RPAREN .)
    GE              reduce using rule 36 (factorI -> LPAREN ExpressionI RPAREN .)
    EQ              reduce using rule 36 (factorI -> LPAREN ExpressionI RPAREN .)
    NEQ             reduce using rule 36 (factorI -> LPAREN ExpressionI RPAREN .)
    PLUS            reduce using rule 36 (factorI -> LPAREN ExpressionI RPAREN .)
    MINUS           reduce using rule 36 (factorI -> LPAREN ExpressionI RPAREN .)
    Then            reduce using rule 36 (factorI -> LPAREN ExpressionI RPAREN .)
    AND             reduce using rule 36 (factorI -> LPAREN ExpressionI RPAREN .)
    OR              reduce using rule 36 (factorI -> LPAREN ExpressionI RPAREN .)
    LBRACKET        reduce using rule 36 (factorI -> LPAREN ExpressionI RPAREN .)
    WriteString     reduce using rule 36 (factorI -> LPAREN ExpressionI RPAREN .)
    Name            reduce using rule 36 (factorI -> LPAREN ExpressionI RPAREN .)
    If              reduce using rule 36 (factorI -> LPAREN ExpressionI RPAREN .)
    While           reduce using rule 36 (factorI -> LPAREN ExpressionI RPAREN .)
    $end            reduce using rule 36 (factorI -> LPAREN ExpressionI RPAREN .)
    RBRACKET        reduce using rule 36 (factorI -> LPAREN ExpressionI RPAREN .)
    RPAREN          reduce using rule 36 (factorI -> LPAREN ExpressionI RPAREN .)


state 87

    (31) TermI -> TermI TIMES factorI .

    TIMES           reduce using rule 31 (TermI -> TermI TIMES factorI .)
    DIVIDE          reduce using rule 31 (TermI -> TermI TIMES factorI .)
    LT              reduce using rule 31 (TermI -> TermI TIMES factorI .)
    LE              reduce using rule 31 (TermI -> TermI TIMES factorI .)
    GT              reduce using rule 31 (TermI -> TermI TIMES factorI .)
    GE              reduce using rule 31 (TermI -> TermI TIMES factorI .)
    EQ              reduce using rule 31 (TermI -> TermI TIMES factorI .)
    NEQ             reduce using rule 31 (TermI -> TermI TIMES factorI .)
    PLUS            reduce using rule 31 (TermI -> TermI TIMES factorI .)
    MINUS           reduce using rule 31 (TermI -> TermI TIMES factorI .)
    Then            reduce using rule 31 (TermI -> TermI TIMES factorI .)
    AND             reduce using rule 31 (TermI -> TermI TIMES factorI .)
    OR              reduce using rule 31 (TermI -> TermI TIMES factorI .)
    LBRACKET        reduce using rule 31 (TermI -> TermI TIMES factorI .)
    WriteString     reduce using rule 31 (TermI -> TermI TIMES factorI .)
    Name            reduce using rule 31 (TermI -> TermI TIMES factorI .)
    If              reduce using rule 31 (TermI -> TermI TIMES factorI .)
    While           reduce using rule 31 (TermI -> TermI TIMES factorI .)
    $end            reduce using rule 31 (TermI -> TermI TIMES factorI .)
    RBRACKET        reduce using rule 31 (TermI -> TermI TIMES factorI .)
    RPAREN          reduce using rule 31 (TermI -> TermI TIMES factorI .)


state 88

    (32) TermI -> TermI DIVIDE factorI .

    TIMES           reduce using rule 32 (TermI -> TermI DIVIDE factorI .)
    DIVIDE          reduce using rule 32 (TermI -> TermI DIVIDE factorI .)
    LT              reduce using rule 32 (TermI -> TermI DIVIDE factorI .)
    LE              reduce using rule 32 (TermI -> TermI DIVIDE factorI .)
    GT              reduce using rule 32 (TermI -> TermI DIVIDE factorI .)
    GE              reduce using rule 32 (TermI -> TermI DIVIDE factorI .)
    EQ              reduce using rule 32 (TermI -> TermI DIVIDE factorI .)
    NEQ             reduce using rule 32 (TermI -> TermI DIVIDE factorI .)
    PLUS            reduce using rule 32 (TermI -> TermI DIVIDE factorI .)
    MINUS           reduce using rule 32 (TermI -> TermI DIVIDE factorI .)
    Then            reduce using rule 32 (TermI -> TermI DIVIDE factorI .)
    AND             reduce using rule 32 (TermI -> TermI DIVIDE factorI .)
    OR              reduce using rule 32 (TermI -> TermI DIVIDE factorI .)
    LBRACKET        reduce using rule 32 (TermI -> TermI DIVIDE factorI .)
    WriteString     reduce using rule 32 (TermI -> TermI DIVIDE factorI .)
    Name            reduce using rule 32 (TermI -> TermI DIVIDE factorI .)
    If              reduce using rule 32 (TermI -> TermI DIVIDE factorI .)
    While           reduce using rule 32 (TermI -> TermI DIVIDE factorI .)
    $end            reduce using rule 32 (TermI -> TermI DIVIDE factorI .)
    RBRACKET        reduce using rule 32 (TermI -> TermI DIVIDE factorI .)
    RPAREN          reduce using rule 32 (TermI -> TermI DIVIDE factorI .)


state 89

    (52) WhileDo -> While ExpressionB LBRACKET CommandBlock . RBRACKET
    (14) CommandBlock -> CommandBlock . Command
    (16) Command -> . Assign
    (27) Command -> . WriteString LPAREN PrintableList RPAREN
    (49) Command -> . IfThenElse
    (51) Command -> . WhileDo
    (17) Assign -> . Name ASSIGN ExpressionI
    (18) Assign -> . Name ASSIGN ExpressionB
    (19) Assign -> . Name ASSIGN String
    (20) Assign -> . Name ASSIGN ReadString LPAREN RPAREN
    (50) IfThenElse -> . If ExpressionB Then LBRACKET CommandBlock RBRACKET Else LBRACKET CommandBlock RBRACKET
    (52) WhileDo -> . While ExpressionB LBRACKET CommandBlock RBRACKET

    RBRACKET        shift and go to state 98
    WriteString     shift and go to state 7
    Name            shift and go to state 10
    If              shift and go to state 11
    While           shift and go to state 12

    Command                        shift and go to state 21
    Assign                         shift and go to state 6
    IfThenElse                     shift and go to state 8
    WhileDo                        shift and go to state 9

state 90

    (8) intvar -> IntDecl Name Decl Integer .

    DeclEnd         reduce using rule 8 (intvar -> IntDecl Name Decl Integer .)
    IntDecl         reduce using rule 8 (intvar -> IntDecl Name Decl Integer .)
    BoolDecl        reduce using rule 8 (intvar -> IntDecl Name Decl Integer .)
    StringDecl      reduce using rule 8 (intvar -> IntDecl Name Decl Integer .)


state 91

    (10) boolvar -> BoolDecl Name Decl Bool .

    DeclEnd         reduce using rule 10 (boolvar -> BoolDecl Name Decl Bool .)
    IntDecl         reduce using rule 10 (boolvar -> BoolDecl Name Decl Bool .)
    BoolDecl        reduce using rule 10 (boolvar -> BoolDecl Name Decl Bool .)
    StringDecl      reduce using rule 10 (boolvar -> BoolDecl Name Decl Bool .)


state 92

    (12) stringvar -> StringDecl Name Decl String .

    DeclEnd         reduce using rule 12 (stringvar -> StringDecl Name Decl String .)
    IntDecl         reduce using rule 12 (stringvar -> StringDecl Name Decl String .)
    BoolDecl        reduce using rule 12 (stringvar -> StringDecl Name Decl String .)
    StringDecl      reduce using rule 12 (stringvar -> StringDecl Name Decl String .)


state 93

    (25) PrintableList -> PrintableList COMMA PrintableElem .

    RPAREN          reduce using rule 25 (PrintableList -> PrintableList COMMA PrintableElem .)
    COMMA           reduce using rule 25 (PrintableList -> PrintableList COMMA PrintableElem .)


state 94

    (20) Assign -> Name ASSIGN ReadString LPAREN RPAREN .

    WriteString     reduce using rule 20 (Assign -> Name ASSIGN ReadString LPAREN RPAREN .)
    Name            reduce using rule 20 (Assign -> Name ASSIGN ReadString LPAREN RPAREN .)
    If              reduce using rule 20 (Assign -> Name ASSIGN ReadString LPAREN RPAREN .)
    While           reduce using rule 20 (Assign -> Name ASSIGN ReadString LPAREN RPAREN .)
    $end            reduce using rule 20 (Assign -> Name ASSIGN ReadString LPAREN RPAREN .)
    RBRACKET        reduce using rule 20 (Assign -> Name ASSIGN ReadString LPAREN RPAREN .)


state 95

    (50) IfThenElse -> If ExpressionB Then LBRACKET CommandBlock . RBRACKET Else LBRACKET CommandBlock RBRACKET
    (14) CommandBlock -> CommandBlock . Command
    (16) Command -> . Assign
    (27) Command -> . WriteString LPAREN PrintableList RPAREN
    (49) Command -> . IfThenElse
    (51) Command -> . WhileDo
    (17) Assign -> . Name ASSIGN ExpressionI
    (18) Assign -> . Name ASSIGN ExpressionB
    (19) Assign -> . Name ASSIGN String
    (20) Assign -> . Name ASSIGN ReadString LPAREN RPAREN
    (50) IfThenElse -> . If ExpressionB Then LBRACKET CommandBlock RBRACKET Else LBRACKET CommandBlock RBRACKET
    (52) WhileDo -> . While ExpressionB LBRACKET CommandBlock RBRACKET

    RBRACKET        shift and go to state 99
    WriteString     shift and go to state 7
    Name            shift and go to state 10
    If              shift and go to state 11
    While           shift and go to state 12

    Command                        shift and go to state 21
    Assign                         shift and go to state 6
    IfThenElse                     shift and go to state 8
    WhileDo                        shift and go to state 9

state 96

    (36) factorI -> LPAREN ExpressionI . RPAREN
    (28) ExpressionI -> ExpressionI . PLUS TermI
    (29) ExpressionI -> ExpressionI . MINUS TermI

    RPAREN          shift and go to state 86
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59


state 97

    (41) ExpressionB -> NOT LPAREN ExpressionB RPAREN .

    Then            reduce using rule 41 (ExpressionB -> NOT LPAREN ExpressionB RPAREN .)
    AND             reduce using rule 41 (ExpressionB -> NOT LPAREN ExpressionB RPAREN .)
    OR              reduce using rule 41 (ExpressionB -> NOT LPAREN ExpressionB RPAREN .)
    LBRACKET        reduce using rule 41 (ExpressionB -> NOT LPAREN ExpressionB RPAREN .)
    WriteString     reduce using rule 41 (ExpressionB -> NOT LPAREN ExpressionB RPAREN .)
    Name            reduce using rule 41 (ExpressionB -> NOT LPAREN ExpressionB RPAREN .)
    If              reduce using rule 41 (ExpressionB -> NOT LPAREN ExpressionB RPAREN .)
    While           reduce using rule 41 (ExpressionB -> NOT LPAREN ExpressionB RPAREN .)
    $end            reduce using rule 41 (ExpressionB -> NOT LPAREN ExpressionB RPAREN .)
    RBRACKET        reduce using rule 41 (ExpressionB -> NOT LPAREN ExpressionB RPAREN .)
    RPAREN          reduce using rule 41 (ExpressionB -> NOT LPAREN ExpressionB RPAREN .)


state 98

    (52) WhileDo -> While ExpressionB LBRACKET CommandBlock RBRACKET .

    WriteString     reduce using rule 52 (WhileDo -> While ExpressionB LBRACKET CommandBlock RBRACKET .)
    Name            reduce using rule 52 (WhileDo -> While ExpressionB LBRACKET CommandBlock RBRACKET .)
    If              reduce using rule 52 (WhileDo -> While ExpressionB LBRACKET CommandBlock RBRACKET .)
    While           reduce using rule 52 (WhileDo -> While ExpressionB LBRACKET CommandBlock RBRACKET .)
    $end            reduce using rule 52 (WhileDo -> While ExpressionB LBRACKET CommandBlock RBRACKET .)
    RBRACKET        reduce using rule 52 (WhileDo -> While ExpressionB LBRACKET CommandBlock RBRACKET .)


state 99

    (50) IfThenElse -> If ExpressionB Then LBRACKET CommandBlock RBRACKET . Else LBRACKET CommandBlock RBRACKET

    Else            shift and go to state 100


state 100

    (50) IfThenElse -> If ExpressionB Then LBRACKET CommandBlock RBRACKET Else . LBRACKET CommandBlock RBRACKET

    LBRACKET        shift and go to state 101


state 101

    (50) IfThenElse -> If ExpressionB Then LBRACKET CommandBlock RBRACKET Else LBRACKET . CommandBlock RBRACKET
    (14) CommandBlock -> . CommandBlock Command
    (15) CommandBlock -> . Command
    (16) Command -> . Assign
    (27) Command -> . WriteString LPAREN PrintableList RPAREN
    (49) Command -> . IfThenElse
    (51) Command -> . WhileDo
    (17) Assign -> . Name ASSIGN ExpressionI
    (18) Assign -> . Name ASSIGN ExpressionB
    (19) Assign -> . Name ASSIGN String
    (20) Assign -> . Name ASSIGN ReadString LPAREN RPAREN
    (50) IfThenElse -> . If ExpressionB Then LBRACKET CommandBlock RBRACKET Else LBRACKET CommandBlock RBRACKET
    (52) WhileDo -> . While ExpressionB LBRACKET CommandBlock RBRACKET

    WriteString     shift and go to state 7
    Name            shift and go to state 10
    If              shift and go to state 11
    While           shift and go to state 12

    CommandBlock                   shift and go to state 102
    Command                        shift and go to state 5
    Assign                         shift and go to state 6
    IfThenElse                     shift and go to state 8
    WhileDo                        shift and go to state 9

state 102

    (50) IfThenElse -> If ExpressionB Then LBRACKET CommandBlock RBRACKET Else LBRACKET CommandBlock . RBRACKET
    (14) CommandBlock -> CommandBlock . Command
    (16) Command -> . Assign
    (27) Command -> . WriteString LPAREN PrintableList RPAREN
    (49) Command -> . IfThenElse
    (51) Command -> . WhileDo
    (17) Assign -> . Name ASSIGN ExpressionI
    (18) Assign -> . Name ASSIGN ExpressionB
    (19) Assign -> . Name ASSIGN String
    (20) Assign -> . Name ASSIGN ReadString LPAREN RPAREN
    (50) IfThenElse -> . If ExpressionB Then LBRACKET CommandBlock RBRACKET Else LBRACKET CommandBlock RBRACKET
    (52) WhileDo -> . While ExpressionB LBRACKET CommandBlock RBRACKET

    RBRACKET        shift and go to state 103
    WriteString     shift and go to state 7
    Name            shift and go to state 10
    If              shift and go to state 11
    While           shift and go to state 12

    Command                        shift and go to state 21
    Assign                         shift and go to state 6
    IfThenElse                     shift and go to state 8
    WhileDo                        shift and go to state 9

state 103

    (50) IfThenElse -> If ExpressionB Then LBRACKET CommandBlock RBRACKET Else LBRACKET CommandBlock RBRACKET .

    WriteString     reduce using rule 50 (IfThenElse -> If ExpressionB Then LBRACKET CommandBlock RBRACKET Else LBRACKET CommandBlock RBRACKET .)
    Name            reduce using rule 50 (IfThenElse -> If ExpressionB Then LBRACKET CommandBlock RBRACKET Else LBRACKET CommandBlock RBRACKET .)
    If              reduce using rule 50 (IfThenElse -> If ExpressionB Then LBRACKET CommandBlock RBRACKET Else LBRACKET CommandBlock RBRACKET .)
    While           reduce using rule 50 (IfThenElse -> If ExpressionB Then LBRACKET CommandBlock RBRACKET Else LBRACKET CommandBlock RBRACKET .)
    $end            reduce using rule 50 (IfThenElse -> If ExpressionB Then LBRACKET CommandBlock RBRACKET Else LBRACKET CommandBlock RBRACKET .)
    RBRACKET        reduce using rule 50 (IfThenElse -> If ExpressionB Then LBRACKET CommandBlock RBRACKET Else LBRACKET CommandBlock RBRACKET .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for RPAREN in state 62 resolved as shift
WARNING: reduce/reduce conflict in state 45 resolved using rule (Assign -> Name ASSIGN ExpressionI)
WARNING: rejected rule (ExpressionB -> ExpressionI) in state 45
