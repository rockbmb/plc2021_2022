Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ATTRIB

Grammar

Rule 0     S' -> program
Rule 1     program -> VARBLOCK
Rule 2     VARBLOCK -> VARBEGIN VARS VAREND
Rule 3     VARS -> VARS VAR
Rule 4     VARS -> <empty>
Rule 5     VAR -> intvar
Rule 6     VAR -> boolvar
Rule 7     VAR -> stringvar
Rule 8     intvar -> INTDECL NAME DECL expressionI
Rule 9     intvar -> INTDECL NAME
Rule 10    boolvar -> BOOLDECL NAME DECL expressionB
Rule 11    stringvar -> STRINGDECL NAME DECL STRING
Rule 12    expressionI -> expressionI PLUS termI
Rule 13    expressionI -> expressionI MINUS termI
Rule 14    expressionI -> termI
Rule 15    termI -> termI TIMES factorI
Rule 16    termI -> termI DIVIDE factorI
Rule 17    termI -> factorI
Rule 18    factorI -> INTEGER
Rule 19    factorI -> NAME
Rule 20    factorI -> LPAREN expressionI RPAREN
Rule 21    expressionB -> TRUE
Rule 22    expressionB -> FALSE
Rule 23    expressionB -> expressionB AND expressionB
Rule 24    expressionB -> expressionB OR expressionB
Rule 25    expressionB -> NOT LPAREN expressionB RPAREN
Rule 26    expressionB -> LPAREN expressionB RPAREN
Rule 27    expressionB -> expressionI LT expressionI
Rule 28    expressionB -> expressionI LE expressionI
Rule 29    expressionB -> expressionI GT expressionI
Rule 30    expressionB -> expressionI GE expressionI
Rule 31    expressionB -> expressionI EQ expressionI
Rule 32    expressionB -> expressionI NEQ expressionI

Terminals, with rules where they appear

AND                  : 23
ATTRIB               : 
BOOLDECL             : 10
DECL                 : 8 10 11
DIVIDE               : 16
EQ                   : 31
FALSE                : 22
GE                   : 30
GT                   : 29
INTDECL              : 8 9
INTEGER              : 18
LE                   : 28
LPAREN               : 20 25 26
LT                   : 27
MINUS                : 13
NAME                 : 8 9 10 11 19
NEQ                  : 32
NOT                  : 25
OR                   : 24
PLUS                 : 12
RPAREN               : 20 25 26
STRING               : 11
STRINGDECL           : 11
TIMES                : 15
TRUE                 : 21
VARBEGIN             : 2
VAREND               : 2
error                : 

Nonterminals, with rules where they appear

VAR                  : 3
VARBLOCK             : 1
VARS                 : 2 3
boolvar              : 6
expressionB          : 10 23 23 24 24 25 26
expressionI          : 8 12 13 20 27 27 28 28 29 29 30 30 31 31 32 32
factorI              : 15 16 17
intvar               : 5
program              : 0
stringvar            : 7
termI                : 12 13 14 15 16

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . VARBLOCK
    (2) VARBLOCK -> . VARBEGIN VARS VAREND

    VARBEGIN        shift and go to state 3

    program                        shift and go to state 1
    VARBLOCK                       shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> VARBLOCK .

    $end            reduce using rule 1 (program -> VARBLOCK .)


state 3

    (2) VARBLOCK -> VARBEGIN . VARS VAREND
    (3) VARS -> . VARS VAR
    (4) VARS -> .

    VAREND          reduce using rule 4 (VARS -> .)
    INTDECL         reduce using rule 4 (VARS -> .)
    BOOLDECL        reduce using rule 4 (VARS -> .)
    STRINGDECL      reduce using rule 4 (VARS -> .)

    VARS                           shift and go to state 4

state 4

    (2) VARBLOCK -> VARBEGIN VARS . VAREND
    (3) VARS -> VARS . VAR
    (5) VAR -> . intvar
    (6) VAR -> . boolvar
    (7) VAR -> . stringvar
    (8) intvar -> . INTDECL NAME DECL expressionI
    (9) intvar -> . INTDECL NAME
    (10) boolvar -> . BOOLDECL NAME DECL expressionB
    (11) stringvar -> . STRINGDECL NAME DECL STRING

    VAREND          shift and go to state 5
    INTDECL         shift and go to state 10
    BOOLDECL        shift and go to state 11
    STRINGDECL      shift and go to state 12

    VAR                            shift and go to state 6
    intvar                         shift and go to state 7
    boolvar                        shift and go to state 8
    stringvar                      shift and go to state 9

state 5

    (2) VARBLOCK -> VARBEGIN VARS VAREND .

    $end            reduce using rule 2 (VARBLOCK -> VARBEGIN VARS VAREND .)


state 6

    (3) VARS -> VARS VAR .

    VAREND          reduce using rule 3 (VARS -> VARS VAR .)
    INTDECL         reduce using rule 3 (VARS -> VARS VAR .)
    BOOLDECL        reduce using rule 3 (VARS -> VARS VAR .)
    STRINGDECL      reduce using rule 3 (VARS -> VARS VAR .)


state 7

    (5) VAR -> intvar .

    VAREND          reduce using rule 5 (VAR -> intvar .)
    INTDECL         reduce using rule 5 (VAR -> intvar .)
    BOOLDECL        reduce using rule 5 (VAR -> intvar .)
    STRINGDECL      reduce using rule 5 (VAR -> intvar .)


state 8

    (6) VAR -> boolvar .

    VAREND          reduce using rule 6 (VAR -> boolvar .)
    INTDECL         reduce using rule 6 (VAR -> boolvar .)
    BOOLDECL        reduce using rule 6 (VAR -> boolvar .)
    STRINGDECL      reduce using rule 6 (VAR -> boolvar .)


state 9

    (7) VAR -> stringvar .

    VAREND          reduce using rule 7 (VAR -> stringvar .)
    INTDECL         reduce using rule 7 (VAR -> stringvar .)
    BOOLDECL        reduce using rule 7 (VAR -> stringvar .)
    STRINGDECL      reduce using rule 7 (VAR -> stringvar .)


state 10

    (8) intvar -> INTDECL . NAME DECL expressionI
    (9) intvar -> INTDECL . NAME

    NAME            shift and go to state 13


state 11

    (10) boolvar -> BOOLDECL . NAME DECL expressionB

    NAME            shift and go to state 14


state 12

    (11) stringvar -> STRINGDECL . NAME DECL STRING

    NAME            shift and go to state 15


state 13

    (8) intvar -> INTDECL NAME . DECL expressionI
    (9) intvar -> INTDECL NAME .

    DECL            shift and go to state 16
    VAREND          reduce using rule 9 (intvar -> INTDECL NAME .)
    INTDECL         reduce using rule 9 (intvar -> INTDECL NAME .)
    BOOLDECL        reduce using rule 9 (intvar -> INTDECL NAME .)
    STRINGDECL      reduce using rule 9 (intvar -> INTDECL NAME .)


state 14

    (10) boolvar -> BOOLDECL NAME . DECL expressionB

    DECL            shift and go to state 17


state 15

    (11) stringvar -> STRINGDECL NAME . DECL STRING

    DECL            shift and go to state 18


state 16

    (8) intvar -> INTDECL NAME DECL . expressionI
    (12) expressionI -> . expressionI PLUS termI
    (13) expressionI -> . expressionI MINUS termI
    (14) expressionI -> . termI
    (15) termI -> . termI TIMES factorI
    (16) termI -> . termI DIVIDE factorI
    (17) termI -> . factorI
    (18) factorI -> . INTEGER
    (19) factorI -> . NAME
    (20) factorI -> . LPAREN expressionI RPAREN

    INTEGER         shift and go to state 23
    NAME            shift and go to state 19
    LPAREN          shift and go to state 24

    expressionI                    shift and go to state 20
    termI                          shift and go to state 21
    factorI                        shift and go to state 22

state 17

    (10) boolvar -> BOOLDECL NAME DECL . expressionB
    (21) expressionB -> . TRUE
    (22) expressionB -> . FALSE
    (23) expressionB -> . expressionB AND expressionB
    (24) expressionB -> . expressionB OR expressionB
    (25) expressionB -> . NOT LPAREN expressionB RPAREN
    (26) expressionB -> . LPAREN expressionB RPAREN
    (27) expressionB -> . expressionI LT expressionI
    (28) expressionB -> . expressionI LE expressionI
    (29) expressionB -> . expressionI GT expressionI
    (30) expressionB -> . expressionI GE expressionI
    (31) expressionB -> . expressionI EQ expressionI
    (32) expressionB -> . expressionI NEQ expressionI
    (12) expressionI -> . expressionI PLUS termI
    (13) expressionI -> . expressionI MINUS termI
    (14) expressionI -> . termI
    (15) termI -> . termI TIMES factorI
    (16) termI -> . termI DIVIDE factorI
    (17) termI -> . factorI
    (18) factorI -> . INTEGER
    (19) factorI -> . NAME
    (20) factorI -> . LPAREN expressionI RPAREN

    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    NOT             shift and go to state 28
    LPAREN          shift and go to state 29
    INTEGER         shift and go to state 23
    NAME            shift and go to state 19

    expressionB                    shift and go to state 25
    expressionI                    shift and go to state 30
    termI                          shift and go to state 21
    factorI                        shift and go to state 22

state 18

    (11) stringvar -> STRINGDECL NAME DECL . STRING

    STRING          shift and go to state 31


state 19

    (19) factorI -> NAME .

    TIMES           reduce using rule 19 (factorI -> NAME .)
    DIVIDE          reduce using rule 19 (factorI -> NAME .)
    PLUS            reduce using rule 19 (factorI -> NAME .)
    MINUS           reduce using rule 19 (factorI -> NAME .)
    VAREND          reduce using rule 19 (factorI -> NAME .)
    INTDECL         reduce using rule 19 (factorI -> NAME .)
    BOOLDECL        reduce using rule 19 (factorI -> NAME .)
    STRINGDECL      reduce using rule 19 (factorI -> NAME .)
    LT              reduce using rule 19 (factorI -> NAME .)
    LE              reduce using rule 19 (factorI -> NAME .)
    GT              reduce using rule 19 (factorI -> NAME .)
    GE              reduce using rule 19 (factorI -> NAME .)
    EQ              reduce using rule 19 (factorI -> NAME .)
    NEQ             reduce using rule 19 (factorI -> NAME .)
    RPAREN          reduce using rule 19 (factorI -> NAME .)
    AND             reduce using rule 19 (factorI -> NAME .)
    OR              reduce using rule 19 (factorI -> NAME .)


state 20

    (8) intvar -> INTDECL NAME DECL expressionI .
    (12) expressionI -> expressionI . PLUS termI
    (13) expressionI -> expressionI . MINUS termI

    VAREND          reduce using rule 8 (intvar -> INTDECL NAME DECL expressionI .)
    INTDECL         reduce using rule 8 (intvar -> INTDECL NAME DECL expressionI .)
    BOOLDECL        reduce using rule 8 (intvar -> INTDECL NAME DECL expressionI .)
    STRINGDECL      reduce using rule 8 (intvar -> INTDECL NAME DECL expressionI .)
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33


state 21

    (14) expressionI -> termI .
    (15) termI -> termI . TIMES factorI
    (16) termI -> termI . DIVIDE factorI

    PLUS            reduce using rule 14 (expressionI -> termI .)
    MINUS           reduce using rule 14 (expressionI -> termI .)
    VAREND          reduce using rule 14 (expressionI -> termI .)
    INTDECL         reduce using rule 14 (expressionI -> termI .)
    BOOLDECL        reduce using rule 14 (expressionI -> termI .)
    STRINGDECL      reduce using rule 14 (expressionI -> termI .)
    LT              reduce using rule 14 (expressionI -> termI .)
    LE              reduce using rule 14 (expressionI -> termI .)
    GT              reduce using rule 14 (expressionI -> termI .)
    GE              reduce using rule 14 (expressionI -> termI .)
    EQ              reduce using rule 14 (expressionI -> termI .)
    NEQ             reduce using rule 14 (expressionI -> termI .)
    RPAREN          reduce using rule 14 (expressionI -> termI .)
    AND             reduce using rule 14 (expressionI -> termI .)
    OR              reduce using rule 14 (expressionI -> termI .)
    TIMES           shift and go to state 34
    DIVIDE          shift and go to state 35


state 22

    (17) termI -> factorI .

    TIMES           reduce using rule 17 (termI -> factorI .)
    DIVIDE          reduce using rule 17 (termI -> factorI .)
    PLUS            reduce using rule 17 (termI -> factorI .)
    MINUS           reduce using rule 17 (termI -> factorI .)
    VAREND          reduce using rule 17 (termI -> factorI .)
    INTDECL         reduce using rule 17 (termI -> factorI .)
    BOOLDECL        reduce using rule 17 (termI -> factorI .)
    STRINGDECL      reduce using rule 17 (termI -> factorI .)
    LT              reduce using rule 17 (termI -> factorI .)
    LE              reduce using rule 17 (termI -> factorI .)
    GT              reduce using rule 17 (termI -> factorI .)
    GE              reduce using rule 17 (termI -> factorI .)
    EQ              reduce using rule 17 (termI -> factorI .)
    NEQ             reduce using rule 17 (termI -> factorI .)
    RPAREN          reduce using rule 17 (termI -> factorI .)
    AND             reduce using rule 17 (termI -> factorI .)
    OR              reduce using rule 17 (termI -> factorI .)


state 23

    (18) factorI -> INTEGER .

    TIMES           reduce using rule 18 (factorI -> INTEGER .)
    DIVIDE          reduce using rule 18 (factorI -> INTEGER .)
    PLUS            reduce using rule 18 (factorI -> INTEGER .)
    MINUS           reduce using rule 18 (factorI -> INTEGER .)
    VAREND          reduce using rule 18 (factorI -> INTEGER .)
    INTDECL         reduce using rule 18 (factorI -> INTEGER .)
    BOOLDECL        reduce using rule 18 (factorI -> INTEGER .)
    STRINGDECL      reduce using rule 18 (factorI -> INTEGER .)
    LT              reduce using rule 18 (factorI -> INTEGER .)
    LE              reduce using rule 18 (factorI -> INTEGER .)
    GT              reduce using rule 18 (factorI -> INTEGER .)
    GE              reduce using rule 18 (factorI -> INTEGER .)
    EQ              reduce using rule 18 (factorI -> INTEGER .)
    NEQ             reduce using rule 18 (factorI -> INTEGER .)
    RPAREN          reduce using rule 18 (factorI -> INTEGER .)
    AND             reduce using rule 18 (factorI -> INTEGER .)
    OR              reduce using rule 18 (factorI -> INTEGER .)


state 24

    (20) factorI -> LPAREN . expressionI RPAREN
    (12) expressionI -> . expressionI PLUS termI
    (13) expressionI -> . expressionI MINUS termI
    (14) expressionI -> . termI
    (15) termI -> . termI TIMES factorI
    (16) termI -> . termI DIVIDE factorI
    (17) termI -> . factorI
    (18) factorI -> . INTEGER
    (19) factorI -> . NAME
    (20) factorI -> . LPAREN expressionI RPAREN

    INTEGER         shift and go to state 23
    NAME            shift and go to state 19
    LPAREN          shift and go to state 24

    expressionI                    shift and go to state 36
    termI                          shift and go to state 21
    factorI                        shift and go to state 22

state 25

    (10) boolvar -> BOOLDECL NAME DECL expressionB .
    (23) expressionB -> expressionB . AND expressionB
    (24) expressionB -> expressionB . OR expressionB

    VAREND          reduce using rule 10 (boolvar -> BOOLDECL NAME DECL expressionB .)
    INTDECL         reduce using rule 10 (boolvar -> BOOLDECL NAME DECL expressionB .)
    BOOLDECL        reduce using rule 10 (boolvar -> BOOLDECL NAME DECL expressionB .)
    STRINGDECL      reduce using rule 10 (boolvar -> BOOLDECL NAME DECL expressionB .)
    AND             shift and go to state 37
    OR              shift and go to state 38


state 26

    (21) expressionB -> TRUE .

    AND             reduce using rule 21 (expressionB -> TRUE .)
    OR              reduce using rule 21 (expressionB -> TRUE .)
    VAREND          reduce using rule 21 (expressionB -> TRUE .)
    INTDECL         reduce using rule 21 (expressionB -> TRUE .)
    BOOLDECL        reduce using rule 21 (expressionB -> TRUE .)
    STRINGDECL      reduce using rule 21 (expressionB -> TRUE .)
    RPAREN          reduce using rule 21 (expressionB -> TRUE .)


state 27

    (22) expressionB -> FALSE .

    AND             reduce using rule 22 (expressionB -> FALSE .)
    OR              reduce using rule 22 (expressionB -> FALSE .)
    VAREND          reduce using rule 22 (expressionB -> FALSE .)
    INTDECL         reduce using rule 22 (expressionB -> FALSE .)
    BOOLDECL        reduce using rule 22 (expressionB -> FALSE .)
    STRINGDECL      reduce using rule 22 (expressionB -> FALSE .)
    RPAREN          reduce using rule 22 (expressionB -> FALSE .)


state 28

    (25) expressionB -> NOT . LPAREN expressionB RPAREN

    LPAREN          shift and go to state 39


state 29

    (26) expressionB -> LPAREN . expressionB RPAREN
    (20) factorI -> LPAREN . expressionI RPAREN
    (21) expressionB -> . TRUE
    (22) expressionB -> . FALSE
    (23) expressionB -> . expressionB AND expressionB
    (24) expressionB -> . expressionB OR expressionB
    (25) expressionB -> . NOT LPAREN expressionB RPAREN
    (26) expressionB -> . LPAREN expressionB RPAREN
    (27) expressionB -> . expressionI LT expressionI
    (28) expressionB -> . expressionI LE expressionI
    (29) expressionB -> . expressionI GT expressionI
    (30) expressionB -> . expressionI GE expressionI
    (31) expressionB -> . expressionI EQ expressionI
    (32) expressionB -> . expressionI NEQ expressionI
    (12) expressionI -> . expressionI PLUS termI
    (13) expressionI -> . expressionI MINUS termI
    (14) expressionI -> . termI
    (15) termI -> . termI TIMES factorI
    (16) termI -> . termI DIVIDE factorI
    (17) termI -> . factorI
    (18) factorI -> . INTEGER
    (19) factorI -> . NAME
    (20) factorI -> . LPAREN expressionI RPAREN

    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    NOT             shift and go to state 28
    LPAREN          shift and go to state 29
    INTEGER         shift and go to state 23
    NAME            shift and go to state 19

    expressionB                    shift and go to state 40
    expressionI                    shift and go to state 41
    termI                          shift and go to state 21
    factorI                        shift and go to state 22

state 30

    (27) expressionB -> expressionI . LT expressionI
    (28) expressionB -> expressionI . LE expressionI
    (29) expressionB -> expressionI . GT expressionI
    (30) expressionB -> expressionI . GE expressionI
    (31) expressionB -> expressionI . EQ expressionI
    (32) expressionB -> expressionI . NEQ expressionI
    (12) expressionI -> expressionI . PLUS termI
    (13) expressionI -> expressionI . MINUS termI

    LT              shift and go to state 42
    LE              shift and go to state 43
    GT              shift and go to state 44
    GE              shift and go to state 45
    EQ              shift and go to state 46
    NEQ             shift and go to state 47
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33


state 31

    (11) stringvar -> STRINGDECL NAME DECL STRING .

    VAREND          reduce using rule 11 (stringvar -> STRINGDECL NAME DECL STRING .)
    INTDECL         reduce using rule 11 (stringvar -> STRINGDECL NAME DECL STRING .)
    BOOLDECL        reduce using rule 11 (stringvar -> STRINGDECL NAME DECL STRING .)
    STRINGDECL      reduce using rule 11 (stringvar -> STRINGDECL NAME DECL STRING .)


state 32

    (12) expressionI -> expressionI PLUS . termI
    (15) termI -> . termI TIMES factorI
    (16) termI -> . termI DIVIDE factorI
    (17) termI -> . factorI
    (18) factorI -> . INTEGER
    (19) factorI -> . NAME
    (20) factorI -> . LPAREN expressionI RPAREN

    INTEGER         shift and go to state 23
    NAME            shift and go to state 19
    LPAREN          shift and go to state 24

    termI                          shift and go to state 48
    factorI                        shift and go to state 22

state 33

    (13) expressionI -> expressionI MINUS . termI
    (15) termI -> . termI TIMES factorI
    (16) termI -> . termI DIVIDE factorI
    (17) termI -> . factorI
    (18) factorI -> . INTEGER
    (19) factorI -> . NAME
    (20) factorI -> . LPAREN expressionI RPAREN

    INTEGER         shift and go to state 23
    NAME            shift and go to state 19
    LPAREN          shift and go to state 24

    termI                          shift and go to state 49
    factorI                        shift and go to state 22

state 34

    (15) termI -> termI TIMES . factorI
    (18) factorI -> . INTEGER
    (19) factorI -> . NAME
    (20) factorI -> . LPAREN expressionI RPAREN

    INTEGER         shift and go to state 23
    NAME            shift and go to state 19
    LPAREN          shift and go to state 24

    factorI                        shift and go to state 50

state 35

    (16) termI -> termI DIVIDE . factorI
    (18) factorI -> . INTEGER
    (19) factorI -> . NAME
    (20) factorI -> . LPAREN expressionI RPAREN

    INTEGER         shift and go to state 23
    NAME            shift and go to state 19
    LPAREN          shift and go to state 24

    factorI                        shift and go to state 51

state 36

    (20) factorI -> LPAREN expressionI . RPAREN
    (12) expressionI -> expressionI . PLUS termI
    (13) expressionI -> expressionI . MINUS termI

    RPAREN          shift and go to state 52
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33


state 37

    (23) expressionB -> expressionB AND . expressionB
    (21) expressionB -> . TRUE
    (22) expressionB -> . FALSE
    (23) expressionB -> . expressionB AND expressionB
    (24) expressionB -> . expressionB OR expressionB
    (25) expressionB -> . NOT LPAREN expressionB RPAREN
    (26) expressionB -> . LPAREN expressionB RPAREN
    (27) expressionB -> . expressionI LT expressionI
    (28) expressionB -> . expressionI LE expressionI
    (29) expressionB -> . expressionI GT expressionI
    (30) expressionB -> . expressionI GE expressionI
    (31) expressionB -> . expressionI EQ expressionI
    (32) expressionB -> . expressionI NEQ expressionI
    (12) expressionI -> . expressionI PLUS termI
    (13) expressionI -> . expressionI MINUS termI
    (14) expressionI -> . termI
    (15) termI -> . termI TIMES factorI
    (16) termI -> . termI DIVIDE factorI
    (17) termI -> . factorI
    (18) factorI -> . INTEGER
    (19) factorI -> . NAME
    (20) factorI -> . LPAREN expressionI RPAREN

    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    NOT             shift and go to state 28
    LPAREN          shift and go to state 29
    INTEGER         shift and go to state 23
    NAME            shift and go to state 19

    expressionB                    shift and go to state 53
    expressionI                    shift and go to state 30
    termI                          shift and go to state 21
    factorI                        shift and go to state 22

state 38

    (24) expressionB -> expressionB OR . expressionB
    (21) expressionB -> . TRUE
    (22) expressionB -> . FALSE
    (23) expressionB -> . expressionB AND expressionB
    (24) expressionB -> . expressionB OR expressionB
    (25) expressionB -> . NOT LPAREN expressionB RPAREN
    (26) expressionB -> . LPAREN expressionB RPAREN
    (27) expressionB -> . expressionI LT expressionI
    (28) expressionB -> . expressionI LE expressionI
    (29) expressionB -> . expressionI GT expressionI
    (30) expressionB -> . expressionI GE expressionI
    (31) expressionB -> . expressionI EQ expressionI
    (32) expressionB -> . expressionI NEQ expressionI
    (12) expressionI -> . expressionI PLUS termI
    (13) expressionI -> . expressionI MINUS termI
    (14) expressionI -> . termI
    (15) termI -> . termI TIMES factorI
    (16) termI -> . termI DIVIDE factorI
    (17) termI -> . factorI
    (18) factorI -> . INTEGER
    (19) factorI -> . NAME
    (20) factorI -> . LPAREN expressionI RPAREN

    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    NOT             shift and go to state 28
    LPAREN          shift and go to state 29
    INTEGER         shift and go to state 23
    NAME            shift and go to state 19

    expressionB                    shift and go to state 54
    expressionI                    shift and go to state 30
    termI                          shift and go to state 21
    factorI                        shift and go to state 22

state 39

    (25) expressionB -> NOT LPAREN . expressionB RPAREN
    (21) expressionB -> . TRUE
    (22) expressionB -> . FALSE
    (23) expressionB -> . expressionB AND expressionB
    (24) expressionB -> . expressionB OR expressionB
    (25) expressionB -> . NOT LPAREN expressionB RPAREN
    (26) expressionB -> . LPAREN expressionB RPAREN
    (27) expressionB -> . expressionI LT expressionI
    (28) expressionB -> . expressionI LE expressionI
    (29) expressionB -> . expressionI GT expressionI
    (30) expressionB -> . expressionI GE expressionI
    (31) expressionB -> . expressionI EQ expressionI
    (32) expressionB -> . expressionI NEQ expressionI
    (12) expressionI -> . expressionI PLUS termI
    (13) expressionI -> . expressionI MINUS termI
    (14) expressionI -> . termI
    (15) termI -> . termI TIMES factorI
    (16) termI -> . termI DIVIDE factorI
    (17) termI -> . factorI
    (18) factorI -> . INTEGER
    (19) factorI -> . NAME
    (20) factorI -> . LPAREN expressionI RPAREN

    TRUE            shift and go to state 26
    FALSE           shift and go to state 27
    NOT             shift and go to state 28
    LPAREN          shift and go to state 29
    INTEGER         shift and go to state 23
    NAME            shift and go to state 19

    expressionB                    shift and go to state 55
    expressionI                    shift and go to state 30
    termI                          shift and go to state 21
    factorI                        shift and go to state 22

state 40

    (26) expressionB -> LPAREN expressionB . RPAREN
    (23) expressionB -> expressionB . AND expressionB
    (24) expressionB -> expressionB . OR expressionB

    RPAREN          shift and go to state 56
    AND             shift and go to state 37
    OR              shift and go to state 38


state 41

    (20) factorI -> LPAREN expressionI . RPAREN
    (27) expressionB -> expressionI . LT expressionI
    (28) expressionB -> expressionI . LE expressionI
    (29) expressionB -> expressionI . GT expressionI
    (30) expressionB -> expressionI . GE expressionI
    (31) expressionB -> expressionI . EQ expressionI
    (32) expressionB -> expressionI . NEQ expressionI
    (12) expressionI -> expressionI . PLUS termI
    (13) expressionI -> expressionI . MINUS termI

    RPAREN          shift and go to state 52
    LT              shift and go to state 42
    LE              shift and go to state 43
    GT              shift and go to state 44
    GE              shift and go to state 45
    EQ              shift and go to state 46
    NEQ             shift and go to state 47
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33


state 42

    (27) expressionB -> expressionI LT . expressionI
    (12) expressionI -> . expressionI PLUS termI
    (13) expressionI -> . expressionI MINUS termI
    (14) expressionI -> . termI
    (15) termI -> . termI TIMES factorI
    (16) termI -> . termI DIVIDE factorI
    (17) termI -> . factorI
    (18) factorI -> . INTEGER
    (19) factorI -> . NAME
    (20) factorI -> . LPAREN expressionI RPAREN

    INTEGER         shift and go to state 23
    NAME            shift and go to state 19
    LPAREN          shift and go to state 24

    expressionI                    shift and go to state 57
    termI                          shift and go to state 21
    factorI                        shift and go to state 22

state 43

    (28) expressionB -> expressionI LE . expressionI
    (12) expressionI -> . expressionI PLUS termI
    (13) expressionI -> . expressionI MINUS termI
    (14) expressionI -> . termI
    (15) termI -> . termI TIMES factorI
    (16) termI -> . termI DIVIDE factorI
    (17) termI -> . factorI
    (18) factorI -> . INTEGER
    (19) factorI -> . NAME
    (20) factorI -> . LPAREN expressionI RPAREN

    INTEGER         shift and go to state 23
    NAME            shift and go to state 19
    LPAREN          shift and go to state 24

    expressionI                    shift and go to state 58
    termI                          shift and go to state 21
    factorI                        shift and go to state 22

state 44

    (29) expressionB -> expressionI GT . expressionI
    (12) expressionI -> . expressionI PLUS termI
    (13) expressionI -> . expressionI MINUS termI
    (14) expressionI -> . termI
    (15) termI -> . termI TIMES factorI
    (16) termI -> . termI DIVIDE factorI
    (17) termI -> . factorI
    (18) factorI -> . INTEGER
    (19) factorI -> . NAME
    (20) factorI -> . LPAREN expressionI RPAREN

    INTEGER         shift and go to state 23
    NAME            shift and go to state 19
    LPAREN          shift and go to state 24

    expressionI                    shift and go to state 59
    termI                          shift and go to state 21
    factorI                        shift and go to state 22

state 45

    (30) expressionB -> expressionI GE . expressionI
    (12) expressionI -> . expressionI PLUS termI
    (13) expressionI -> . expressionI MINUS termI
    (14) expressionI -> . termI
    (15) termI -> . termI TIMES factorI
    (16) termI -> . termI DIVIDE factorI
    (17) termI -> . factorI
    (18) factorI -> . INTEGER
    (19) factorI -> . NAME
    (20) factorI -> . LPAREN expressionI RPAREN

    INTEGER         shift and go to state 23
    NAME            shift and go to state 19
    LPAREN          shift and go to state 24

    expressionI                    shift and go to state 60
    termI                          shift and go to state 21
    factorI                        shift and go to state 22

state 46

    (31) expressionB -> expressionI EQ . expressionI
    (12) expressionI -> . expressionI PLUS termI
    (13) expressionI -> . expressionI MINUS termI
    (14) expressionI -> . termI
    (15) termI -> . termI TIMES factorI
    (16) termI -> . termI DIVIDE factorI
    (17) termI -> . factorI
    (18) factorI -> . INTEGER
    (19) factorI -> . NAME
    (20) factorI -> . LPAREN expressionI RPAREN

    INTEGER         shift and go to state 23
    NAME            shift and go to state 19
    LPAREN          shift and go to state 24

    expressionI                    shift and go to state 61
    termI                          shift and go to state 21
    factorI                        shift and go to state 22

state 47

    (32) expressionB -> expressionI NEQ . expressionI
    (12) expressionI -> . expressionI PLUS termI
    (13) expressionI -> . expressionI MINUS termI
    (14) expressionI -> . termI
    (15) termI -> . termI TIMES factorI
    (16) termI -> . termI DIVIDE factorI
    (17) termI -> . factorI
    (18) factorI -> . INTEGER
    (19) factorI -> . NAME
    (20) factorI -> . LPAREN expressionI RPAREN

    INTEGER         shift and go to state 23
    NAME            shift and go to state 19
    LPAREN          shift and go to state 24

    expressionI                    shift and go to state 62
    termI                          shift and go to state 21
    factorI                        shift and go to state 22

state 48

    (12) expressionI -> expressionI PLUS termI .
    (15) termI -> termI . TIMES factorI
    (16) termI -> termI . DIVIDE factorI

    PLUS            reduce using rule 12 (expressionI -> expressionI PLUS termI .)
    MINUS           reduce using rule 12 (expressionI -> expressionI PLUS termI .)
    VAREND          reduce using rule 12 (expressionI -> expressionI PLUS termI .)
    INTDECL         reduce using rule 12 (expressionI -> expressionI PLUS termI .)
    BOOLDECL        reduce using rule 12 (expressionI -> expressionI PLUS termI .)
    STRINGDECL      reduce using rule 12 (expressionI -> expressionI PLUS termI .)
    LT              reduce using rule 12 (expressionI -> expressionI PLUS termI .)
    LE              reduce using rule 12 (expressionI -> expressionI PLUS termI .)
    GT              reduce using rule 12 (expressionI -> expressionI PLUS termI .)
    GE              reduce using rule 12 (expressionI -> expressionI PLUS termI .)
    EQ              reduce using rule 12 (expressionI -> expressionI PLUS termI .)
    NEQ             reduce using rule 12 (expressionI -> expressionI PLUS termI .)
    RPAREN          reduce using rule 12 (expressionI -> expressionI PLUS termI .)
    AND             reduce using rule 12 (expressionI -> expressionI PLUS termI .)
    OR              reduce using rule 12 (expressionI -> expressionI PLUS termI .)
    TIMES           shift and go to state 34
    DIVIDE          shift and go to state 35


state 49

    (13) expressionI -> expressionI MINUS termI .
    (15) termI -> termI . TIMES factorI
    (16) termI -> termI . DIVIDE factorI

    PLUS            reduce using rule 13 (expressionI -> expressionI MINUS termI .)
    MINUS           reduce using rule 13 (expressionI -> expressionI MINUS termI .)
    VAREND          reduce using rule 13 (expressionI -> expressionI MINUS termI .)
    INTDECL         reduce using rule 13 (expressionI -> expressionI MINUS termI .)
    BOOLDECL        reduce using rule 13 (expressionI -> expressionI MINUS termI .)
    STRINGDECL      reduce using rule 13 (expressionI -> expressionI MINUS termI .)
    LT              reduce using rule 13 (expressionI -> expressionI MINUS termI .)
    LE              reduce using rule 13 (expressionI -> expressionI MINUS termI .)
    GT              reduce using rule 13 (expressionI -> expressionI MINUS termI .)
    GE              reduce using rule 13 (expressionI -> expressionI MINUS termI .)
    EQ              reduce using rule 13 (expressionI -> expressionI MINUS termI .)
    NEQ             reduce using rule 13 (expressionI -> expressionI MINUS termI .)
    RPAREN          reduce using rule 13 (expressionI -> expressionI MINUS termI .)
    AND             reduce using rule 13 (expressionI -> expressionI MINUS termI .)
    OR              reduce using rule 13 (expressionI -> expressionI MINUS termI .)
    TIMES           shift and go to state 34
    DIVIDE          shift and go to state 35


state 50

    (15) termI -> termI TIMES factorI .

    TIMES           reduce using rule 15 (termI -> termI TIMES factorI .)
    DIVIDE          reduce using rule 15 (termI -> termI TIMES factorI .)
    PLUS            reduce using rule 15 (termI -> termI TIMES factorI .)
    MINUS           reduce using rule 15 (termI -> termI TIMES factorI .)
    VAREND          reduce using rule 15 (termI -> termI TIMES factorI .)
    INTDECL         reduce using rule 15 (termI -> termI TIMES factorI .)
    BOOLDECL        reduce using rule 15 (termI -> termI TIMES factorI .)
    STRINGDECL      reduce using rule 15 (termI -> termI TIMES factorI .)
    LT              reduce using rule 15 (termI -> termI TIMES factorI .)
    LE              reduce using rule 15 (termI -> termI TIMES factorI .)
    GT              reduce using rule 15 (termI -> termI TIMES factorI .)
    GE              reduce using rule 15 (termI -> termI TIMES factorI .)
    EQ              reduce using rule 15 (termI -> termI TIMES factorI .)
    NEQ             reduce using rule 15 (termI -> termI TIMES factorI .)
    RPAREN          reduce using rule 15 (termI -> termI TIMES factorI .)
    AND             reduce using rule 15 (termI -> termI TIMES factorI .)
    OR              reduce using rule 15 (termI -> termI TIMES factorI .)


state 51

    (16) termI -> termI DIVIDE factorI .

    TIMES           reduce using rule 16 (termI -> termI DIVIDE factorI .)
    DIVIDE          reduce using rule 16 (termI -> termI DIVIDE factorI .)
    PLUS            reduce using rule 16 (termI -> termI DIVIDE factorI .)
    MINUS           reduce using rule 16 (termI -> termI DIVIDE factorI .)
    VAREND          reduce using rule 16 (termI -> termI DIVIDE factorI .)
    INTDECL         reduce using rule 16 (termI -> termI DIVIDE factorI .)
    BOOLDECL        reduce using rule 16 (termI -> termI DIVIDE factorI .)
    STRINGDECL      reduce using rule 16 (termI -> termI DIVIDE factorI .)
    LT              reduce using rule 16 (termI -> termI DIVIDE factorI .)
    LE              reduce using rule 16 (termI -> termI DIVIDE factorI .)
    GT              reduce using rule 16 (termI -> termI DIVIDE factorI .)
    GE              reduce using rule 16 (termI -> termI DIVIDE factorI .)
    EQ              reduce using rule 16 (termI -> termI DIVIDE factorI .)
    NEQ             reduce using rule 16 (termI -> termI DIVIDE factorI .)
    RPAREN          reduce using rule 16 (termI -> termI DIVIDE factorI .)
    AND             reduce using rule 16 (termI -> termI DIVIDE factorI .)
    OR              reduce using rule 16 (termI -> termI DIVIDE factorI .)


state 52

    (20) factorI -> LPAREN expressionI RPAREN .

    TIMES           reduce using rule 20 (factorI -> LPAREN expressionI RPAREN .)
    DIVIDE          reduce using rule 20 (factorI -> LPAREN expressionI RPAREN .)
    PLUS            reduce using rule 20 (factorI -> LPAREN expressionI RPAREN .)
    MINUS           reduce using rule 20 (factorI -> LPAREN expressionI RPAREN .)
    VAREND          reduce using rule 20 (factorI -> LPAREN expressionI RPAREN .)
    INTDECL         reduce using rule 20 (factorI -> LPAREN expressionI RPAREN .)
    BOOLDECL        reduce using rule 20 (factorI -> LPAREN expressionI RPAREN .)
    STRINGDECL      reduce using rule 20 (factorI -> LPAREN expressionI RPAREN .)
    LT              reduce using rule 20 (factorI -> LPAREN expressionI RPAREN .)
    LE              reduce using rule 20 (factorI -> LPAREN expressionI RPAREN .)
    GT              reduce using rule 20 (factorI -> LPAREN expressionI RPAREN .)
    GE              reduce using rule 20 (factorI -> LPAREN expressionI RPAREN .)
    EQ              reduce using rule 20 (factorI -> LPAREN expressionI RPAREN .)
    NEQ             reduce using rule 20 (factorI -> LPAREN expressionI RPAREN .)
    RPAREN          reduce using rule 20 (factorI -> LPAREN expressionI RPAREN .)
    AND             reduce using rule 20 (factorI -> LPAREN expressionI RPAREN .)
    OR              reduce using rule 20 (factorI -> LPAREN expressionI RPAREN .)


state 53

    (23) expressionB -> expressionB AND expressionB .
    (23) expressionB -> expressionB . AND expressionB
    (24) expressionB -> expressionB . OR expressionB

    AND             reduce using rule 23 (expressionB -> expressionB AND expressionB .)
    VAREND          reduce using rule 23 (expressionB -> expressionB AND expressionB .)
    INTDECL         reduce using rule 23 (expressionB -> expressionB AND expressionB .)
    BOOLDECL        reduce using rule 23 (expressionB -> expressionB AND expressionB .)
    STRINGDECL      reduce using rule 23 (expressionB -> expressionB AND expressionB .)
    RPAREN          reduce using rule 23 (expressionB -> expressionB AND expressionB .)
    OR              shift and go to state 38

  ! OR              [ reduce using rule 23 (expressionB -> expressionB AND expressionB .) ]
  ! AND             [ shift and go to state 37 ]


state 54

    (24) expressionB -> expressionB OR expressionB .
    (23) expressionB -> expressionB . AND expressionB
    (24) expressionB -> expressionB . OR expressionB

    AND             reduce using rule 24 (expressionB -> expressionB OR expressionB .)
    OR              reduce using rule 24 (expressionB -> expressionB OR expressionB .)
    VAREND          reduce using rule 24 (expressionB -> expressionB OR expressionB .)
    INTDECL         reduce using rule 24 (expressionB -> expressionB OR expressionB .)
    BOOLDECL        reduce using rule 24 (expressionB -> expressionB OR expressionB .)
    STRINGDECL      reduce using rule 24 (expressionB -> expressionB OR expressionB .)
    RPAREN          reduce using rule 24 (expressionB -> expressionB OR expressionB .)

  ! AND             [ shift and go to state 37 ]
  ! OR              [ shift and go to state 38 ]


state 55

    (25) expressionB -> NOT LPAREN expressionB . RPAREN
    (23) expressionB -> expressionB . AND expressionB
    (24) expressionB -> expressionB . OR expressionB

    RPAREN          shift and go to state 63
    AND             shift and go to state 37
    OR              shift and go to state 38


state 56

    (26) expressionB -> LPAREN expressionB RPAREN .

    AND             reduce using rule 26 (expressionB -> LPAREN expressionB RPAREN .)
    OR              reduce using rule 26 (expressionB -> LPAREN expressionB RPAREN .)
    VAREND          reduce using rule 26 (expressionB -> LPAREN expressionB RPAREN .)
    INTDECL         reduce using rule 26 (expressionB -> LPAREN expressionB RPAREN .)
    BOOLDECL        reduce using rule 26 (expressionB -> LPAREN expressionB RPAREN .)
    STRINGDECL      reduce using rule 26 (expressionB -> LPAREN expressionB RPAREN .)
    RPAREN          reduce using rule 26 (expressionB -> LPAREN expressionB RPAREN .)


state 57

    (27) expressionB -> expressionI LT expressionI .
    (12) expressionI -> expressionI . PLUS termI
    (13) expressionI -> expressionI . MINUS termI

    AND             reduce using rule 27 (expressionB -> expressionI LT expressionI .)
    OR              reduce using rule 27 (expressionB -> expressionI LT expressionI .)
    VAREND          reduce using rule 27 (expressionB -> expressionI LT expressionI .)
    INTDECL         reduce using rule 27 (expressionB -> expressionI LT expressionI .)
    BOOLDECL        reduce using rule 27 (expressionB -> expressionI LT expressionI .)
    STRINGDECL      reduce using rule 27 (expressionB -> expressionI LT expressionI .)
    RPAREN          reduce using rule 27 (expressionB -> expressionI LT expressionI .)
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33


state 58

    (28) expressionB -> expressionI LE expressionI .
    (12) expressionI -> expressionI . PLUS termI
    (13) expressionI -> expressionI . MINUS termI

    AND             reduce using rule 28 (expressionB -> expressionI LE expressionI .)
    OR              reduce using rule 28 (expressionB -> expressionI LE expressionI .)
    VAREND          reduce using rule 28 (expressionB -> expressionI LE expressionI .)
    INTDECL         reduce using rule 28 (expressionB -> expressionI LE expressionI .)
    BOOLDECL        reduce using rule 28 (expressionB -> expressionI LE expressionI .)
    STRINGDECL      reduce using rule 28 (expressionB -> expressionI LE expressionI .)
    RPAREN          reduce using rule 28 (expressionB -> expressionI LE expressionI .)
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33


state 59

    (29) expressionB -> expressionI GT expressionI .
    (12) expressionI -> expressionI . PLUS termI
    (13) expressionI -> expressionI . MINUS termI

    AND             reduce using rule 29 (expressionB -> expressionI GT expressionI .)
    OR              reduce using rule 29 (expressionB -> expressionI GT expressionI .)
    VAREND          reduce using rule 29 (expressionB -> expressionI GT expressionI .)
    INTDECL         reduce using rule 29 (expressionB -> expressionI GT expressionI .)
    BOOLDECL        reduce using rule 29 (expressionB -> expressionI GT expressionI .)
    STRINGDECL      reduce using rule 29 (expressionB -> expressionI GT expressionI .)
    RPAREN          reduce using rule 29 (expressionB -> expressionI GT expressionI .)
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33


state 60

    (30) expressionB -> expressionI GE expressionI .
    (12) expressionI -> expressionI . PLUS termI
    (13) expressionI -> expressionI . MINUS termI

    AND             reduce using rule 30 (expressionB -> expressionI GE expressionI .)
    OR              reduce using rule 30 (expressionB -> expressionI GE expressionI .)
    VAREND          reduce using rule 30 (expressionB -> expressionI GE expressionI .)
    INTDECL         reduce using rule 30 (expressionB -> expressionI GE expressionI .)
    BOOLDECL        reduce using rule 30 (expressionB -> expressionI GE expressionI .)
    STRINGDECL      reduce using rule 30 (expressionB -> expressionI GE expressionI .)
    RPAREN          reduce using rule 30 (expressionB -> expressionI GE expressionI .)
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33


state 61

    (31) expressionB -> expressionI EQ expressionI .
    (12) expressionI -> expressionI . PLUS termI
    (13) expressionI -> expressionI . MINUS termI

    AND             reduce using rule 31 (expressionB -> expressionI EQ expressionI .)
    OR              reduce using rule 31 (expressionB -> expressionI EQ expressionI .)
    VAREND          reduce using rule 31 (expressionB -> expressionI EQ expressionI .)
    INTDECL         reduce using rule 31 (expressionB -> expressionI EQ expressionI .)
    BOOLDECL        reduce using rule 31 (expressionB -> expressionI EQ expressionI .)
    STRINGDECL      reduce using rule 31 (expressionB -> expressionI EQ expressionI .)
    RPAREN          reduce using rule 31 (expressionB -> expressionI EQ expressionI .)
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33


state 62

    (32) expressionB -> expressionI NEQ expressionI .
    (12) expressionI -> expressionI . PLUS termI
    (13) expressionI -> expressionI . MINUS termI

    AND             reduce using rule 32 (expressionB -> expressionI NEQ expressionI .)
    OR              reduce using rule 32 (expressionB -> expressionI NEQ expressionI .)
    VAREND          reduce using rule 32 (expressionB -> expressionI NEQ expressionI .)
    INTDECL         reduce using rule 32 (expressionB -> expressionI NEQ expressionI .)
    BOOLDECL        reduce using rule 32 (expressionB -> expressionI NEQ expressionI .)
    STRINGDECL      reduce using rule 32 (expressionB -> expressionI NEQ expressionI .)
    RPAREN          reduce using rule 32 (expressionB -> expressionI NEQ expressionI .)
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33


state 63

    (25) expressionB -> NOT LPAREN expressionB RPAREN .

    AND             reduce using rule 25 (expressionB -> NOT LPAREN expressionB RPAREN .)
    OR              reduce using rule 25 (expressionB -> NOT LPAREN expressionB RPAREN .)
    VAREND          reduce using rule 25 (expressionB -> NOT LPAREN expressionB RPAREN .)
    INTDECL         reduce using rule 25 (expressionB -> NOT LPAREN expressionB RPAREN .)
    BOOLDECL        reduce using rule 25 (expressionB -> NOT LPAREN expressionB RPAREN .)
    STRINGDECL      reduce using rule 25 (expressionB -> NOT LPAREN expressionB RPAREN .)
    RPAREN          reduce using rule 25 (expressionB -> NOT LPAREN expressionB RPAREN .)

