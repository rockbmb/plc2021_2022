Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ATTRIB

Grammar

Rule 0     S' -> program
Rule 1     program -> VARBLOCK
Rule 2     VARBLOCK -> VARBEGIN VARS VAREND
Rule 3     VARS -> VARS VAR
Rule 4     VARS -> <empty>
Rule 5     VAR -> intvar
Rule 6     VAR -> boolvar
Rule 7     intvar -> INTDECL NAME DECL expressionI
Rule 8     intvar -> INTDECL NAME
Rule 9     boolvar -> BOOLDECL NAME DECL expressionB
Rule 10    expressionI -> expressionI PLUS termI
Rule 11    expressionI -> expressionI MINUS termI
Rule 12    expressionI -> termI
Rule 13    termI -> termI TIMES factorI
Rule 14    termI -> termI DIVIDE factorI
Rule 15    termI -> factorI
Rule 16    factorI -> INTEGER
Rule 17    factorI -> NAME
Rule 18    factorI -> LPAREN expressionI RPAREN
Rule 19    expressionB -> TRUE
Rule 20    expressionB -> FALSE
Rule 21    expressionB -> expressionB AND expressionB
Rule 22    expressionB -> expressionB OR expressionB
Rule 23    expressionB -> NOT LPAREN expressionB RPAREN
Rule 24    expressionB -> LPAREN expressionB RPAREN
Rule 25    expressionB -> expressionI LT expressionI
Rule 26    expressionB -> expressionI LE expressionI
Rule 27    expressionB -> expressionI GT expressionI
Rule 28    expressionB -> expressionI GE expressionI
Rule 29    expressionB -> expressionI EQ expressionI
Rule 30    expressionB -> expressionI NEQ expressionI

Terminals, with rules where they appear

AND                  : 21
ATTRIB               : 
BOOLDECL             : 9
DECL                 : 7 9
DIVIDE               : 14
EQ                   : 29
FALSE                : 20
GE                   : 28
GT                   : 27
INTDECL              : 7 8
INTEGER              : 16
LE                   : 26
LPAREN               : 18 23 24
LT                   : 25
MINUS                : 11
NAME                 : 7 8 9 17
NEQ                  : 30
NOT                  : 23
OR                   : 22
PLUS                 : 10
RPAREN               : 18 23 24
TIMES                : 13
TRUE                 : 19
VARBEGIN             : 2
VAREND               : 2
error                : 

Nonterminals, with rules where they appear

VAR                  : 3
VARBLOCK             : 1
VARS                 : 2 3
boolvar              : 6
expressionB          : 9 21 21 22 22 23 24
expressionI          : 7 10 11 18 25 25 26 26 27 27 28 28 29 29 30 30
factorI              : 13 14 15
intvar               : 5
program              : 0
termI                : 10 11 12 13 14

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . VARBLOCK
    (2) VARBLOCK -> . VARBEGIN VARS VAREND

    VARBEGIN        shift and go to state 3

    program                        shift and go to state 1
    VARBLOCK                       shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> VARBLOCK .

    $end            reduce using rule 1 (program -> VARBLOCK .)


state 3

    (2) VARBLOCK -> VARBEGIN . VARS VAREND
    (3) VARS -> . VARS VAR
    (4) VARS -> .

    VAREND          reduce using rule 4 (VARS -> .)
    INTDECL         reduce using rule 4 (VARS -> .)
    BOOLDECL        reduce using rule 4 (VARS -> .)

    VARS                           shift and go to state 4

state 4

    (2) VARBLOCK -> VARBEGIN VARS . VAREND
    (3) VARS -> VARS . VAR
    (5) VAR -> . intvar
    (6) VAR -> . boolvar
    (7) intvar -> . INTDECL NAME DECL expressionI
    (8) intvar -> . INTDECL NAME
    (9) boolvar -> . BOOLDECL NAME DECL expressionB

    VAREND          shift and go to state 5
    INTDECL         shift and go to state 9
    BOOLDECL        shift and go to state 10

    VAR                            shift and go to state 6
    intvar                         shift and go to state 7
    boolvar                        shift and go to state 8

state 5

    (2) VARBLOCK -> VARBEGIN VARS VAREND .

    $end            reduce using rule 2 (VARBLOCK -> VARBEGIN VARS VAREND .)


state 6

    (3) VARS -> VARS VAR .

    VAREND          reduce using rule 3 (VARS -> VARS VAR .)
    INTDECL         reduce using rule 3 (VARS -> VARS VAR .)
    BOOLDECL        reduce using rule 3 (VARS -> VARS VAR .)


state 7

    (5) VAR -> intvar .

    VAREND          reduce using rule 5 (VAR -> intvar .)
    INTDECL         reduce using rule 5 (VAR -> intvar .)
    BOOLDECL        reduce using rule 5 (VAR -> intvar .)


state 8

    (6) VAR -> boolvar .

    VAREND          reduce using rule 6 (VAR -> boolvar .)
    INTDECL         reduce using rule 6 (VAR -> boolvar .)
    BOOLDECL        reduce using rule 6 (VAR -> boolvar .)


state 9

    (7) intvar -> INTDECL . NAME DECL expressionI
    (8) intvar -> INTDECL . NAME

    NAME            shift and go to state 11


state 10

    (9) boolvar -> BOOLDECL . NAME DECL expressionB

    NAME            shift and go to state 12


state 11

    (7) intvar -> INTDECL NAME . DECL expressionI
    (8) intvar -> INTDECL NAME .

    DECL            shift and go to state 13
    VAREND          reduce using rule 8 (intvar -> INTDECL NAME .)
    INTDECL         reduce using rule 8 (intvar -> INTDECL NAME .)
    BOOLDECL        reduce using rule 8 (intvar -> INTDECL NAME .)


state 12

    (9) boolvar -> BOOLDECL NAME . DECL expressionB

    DECL            shift and go to state 14


state 13

    (7) intvar -> INTDECL NAME DECL . expressionI
    (10) expressionI -> . expressionI PLUS termI
    (11) expressionI -> . expressionI MINUS termI
    (12) expressionI -> . termI
    (13) termI -> . termI TIMES factorI
    (14) termI -> . termI DIVIDE factorI
    (15) termI -> . factorI
    (16) factorI -> . INTEGER
    (17) factorI -> . NAME
    (18) factorI -> . LPAREN expressionI RPAREN

    INTEGER         shift and go to state 19
    NAME            shift and go to state 15
    LPAREN          shift and go to state 20

    expressionI                    shift and go to state 16
    termI                          shift and go to state 17
    factorI                        shift and go to state 18

state 14

    (9) boolvar -> BOOLDECL NAME DECL . expressionB
    (19) expressionB -> . TRUE
    (20) expressionB -> . FALSE
    (21) expressionB -> . expressionB AND expressionB
    (22) expressionB -> . expressionB OR expressionB
    (23) expressionB -> . NOT LPAREN expressionB RPAREN
    (24) expressionB -> . LPAREN expressionB RPAREN
    (25) expressionB -> . expressionI LT expressionI
    (26) expressionB -> . expressionI LE expressionI
    (27) expressionB -> . expressionI GT expressionI
    (28) expressionB -> . expressionI GE expressionI
    (29) expressionB -> . expressionI EQ expressionI
    (30) expressionB -> . expressionI NEQ expressionI
    (10) expressionI -> . expressionI PLUS termI
    (11) expressionI -> . expressionI MINUS termI
    (12) expressionI -> . termI
    (13) termI -> . termI TIMES factorI
    (14) termI -> . termI DIVIDE factorI
    (15) termI -> . factorI
    (16) factorI -> . INTEGER
    (17) factorI -> . NAME
    (18) factorI -> . LPAREN expressionI RPAREN

    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24
    LPAREN          shift and go to state 25
    INTEGER         shift and go to state 19
    NAME            shift and go to state 15

    expressionB                    shift and go to state 21
    expressionI                    shift and go to state 26
    termI                          shift and go to state 17
    factorI                        shift and go to state 18

state 15

    (17) factorI -> NAME .

    TIMES           reduce using rule 17 (factorI -> NAME .)
    DIVIDE          reduce using rule 17 (factorI -> NAME .)
    PLUS            reduce using rule 17 (factorI -> NAME .)
    MINUS           reduce using rule 17 (factorI -> NAME .)
    VAREND          reduce using rule 17 (factorI -> NAME .)
    INTDECL         reduce using rule 17 (factorI -> NAME .)
    BOOLDECL        reduce using rule 17 (factorI -> NAME .)
    LT              reduce using rule 17 (factorI -> NAME .)
    LE              reduce using rule 17 (factorI -> NAME .)
    GT              reduce using rule 17 (factorI -> NAME .)
    GE              reduce using rule 17 (factorI -> NAME .)
    EQ              reduce using rule 17 (factorI -> NAME .)
    NEQ             reduce using rule 17 (factorI -> NAME .)
    RPAREN          reduce using rule 17 (factorI -> NAME .)
    AND             reduce using rule 17 (factorI -> NAME .)
    OR              reduce using rule 17 (factorI -> NAME .)


state 16

    (7) intvar -> INTDECL NAME DECL expressionI .
    (10) expressionI -> expressionI . PLUS termI
    (11) expressionI -> expressionI . MINUS termI

    VAREND          reduce using rule 7 (intvar -> INTDECL NAME DECL expressionI .)
    INTDECL         reduce using rule 7 (intvar -> INTDECL NAME DECL expressionI .)
    BOOLDECL        reduce using rule 7 (intvar -> INTDECL NAME DECL expressionI .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28


state 17

    (12) expressionI -> termI .
    (13) termI -> termI . TIMES factorI
    (14) termI -> termI . DIVIDE factorI

    PLUS            reduce using rule 12 (expressionI -> termI .)
    MINUS           reduce using rule 12 (expressionI -> termI .)
    VAREND          reduce using rule 12 (expressionI -> termI .)
    INTDECL         reduce using rule 12 (expressionI -> termI .)
    BOOLDECL        reduce using rule 12 (expressionI -> termI .)
    LT              reduce using rule 12 (expressionI -> termI .)
    LE              reduce using rule 12 (expressionI -> termI .)
    GT              reduce using rule 12 (expressionI -> termI .)
    GE              reduce using rule 12 (expressionI -> termI .)
    EQ              reduce using rule 12 (expressionI -> termI .)
    NEQ             reduce using rule 12 (expressionI -> termI .)
    RPAREN          reduce using rule 12 (expressionI -> termI .)
    AND             reduce using rule 12 (expressionI -> termI .)
    OR              reduce using rule 12 (expressionI -> termI .)
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30


state 18

    (15) termI -> factorI .

    TIMES           reduce using rule 15 (termI -> factorI .)
    DIVIDE          reduce using rule 15 (termI -> factorI .)
    PLUS            reduce using rule 15 (termI -> factorI .)
    MINUS           reduce using rule 15 (termI -> factorI .)
    VAREND          reduce using rule 15 (termI -> factorI .)
    INTDECL         reduce using rule 15 (termI -> factorI .)
    BOOLDECL        reduce using rule 15 (termI -> factorI .)
    LT              reduce using rule 15 (termI -> factorI .)
    LE              reduce using rule 15 (termI -> factorI .)
    GT              reduce using rule 15 (termI -> factorI .)
    GE              reduce using rule 15 (termI -> factorI .)
    EQ              reduce using rule 15 (termI -> factorI .)
    NEQ             reduce using rule 15 (termI -> factorI .)
    RPAREN          reduce using rule 15 (termI -> factorI .)
    AND             reduce using rule 15 (termI -> factorI .)
    OR              reduce using rule 15 (termI -> factorI .)


state 19

    (16) factorI -> INTEGER .

    TIMES           reduce using rule 16 (factorI -> INTEGER .)
    DIVIDE          reduce using rule 16 (factorI -> INTEGER .)
    PLUS            reduce using rule 16 (factorI -> INTEGER .)
    MINUS           reduce using rule 16 (factorI -> INTEGER .)
    VAREND          reduce using rule 16 (factorI -> INTEGER .)
    INTDECL         reduce using rule 16 (factorI -> INTEGER .)
    BOOLDECL        reduce using rule 16 (factorI -> INTEGER .)
    LT              reduce using rule 16 (factorI -> INTEGER .)
    LE              reduce using rule 16 (factorI -> INTEGER .)
    GT              reduce using rule 16 (factorI -> INTEGER .)
    GE              reduce using rule 16 (factorI -> INTEGER .)
    EQ              reduce using rule 16 (factorI -> INTEGER .)
    NEQ             reduce using rule 16 (factorI -> INTEGER .)
    RPAREN          reduce using rule 16 (factorI -> INTEGER .)
    AND             reduce using rule 16 (factorI -> INTEGER .)
    OR              reduce using rule 16 (factorI -> INTEGER .)


state 20

    (18) factorI -> LPAREN . expressionI RPAREN
    (10) expressionI -> . expressionI PLUS termI
    (11) expressionI -> . expressionI MINUS termI
    (12) expressionI -> . termI
    (13) termI -> . termI TIMES factorI
    (14) termI -> . termI DIVIDE factorI
    (15) termI -> . factorI
    (16) factorI -> . INTEGER
    (17) factorI -> . NAME
    (18) factorI -> . LPAREN expressionI RPAREN

    INTEGER         shift and go to state 19
    NAME            shift and go to state 15
    LPAREN          shift and go to state 20

    expressionI                    shift and go to state 31
    termI                          shift and go to state 17
    factorI                        shift and go to state 18

state 21

    (9) boolvar -> BOOLDECL NAME DECL expressionB .
    (21) expressionB -> expressionB . AND expressionB
    (22) expressionB -> expressionB . OR expressionB

    VAREND          reduce using rule 9 (boolvar -> BOOLDECL NAME DECL expressionB .)
    INTDECL         reduce using rule 9 (boolvar -> BOOLDECL NAME DECL expressionB .)
    BOOLDECL        reduce using rule 9 (boolvar -> BOOLDECL NAME DECL expressionB .)
    AND             shift and go to state 32
    OR              shift and go to state 33


state 22

    (19) expressionB -> TRUE .

    AND             reduce using rule 19 (expressionB -> TRUE .)
    OR              reduce using rule 19 (expressionB -> TRUE .)
    VAREND          reduce using rule 19 (expressionB -> TRUE .)
    INTDECL         reduce using rule 19 (expressionB -> TRUE .)
    BOOLDECL        reduce using rule 19 (expressionB -> TRUE .)
    RPAREN          reduce using rule 19 (expressionB -> TRUE .)


state 23

    (20) expressionB -> FALSE .

    AND             reduce using rule 20 (expressionB -> FALSE .)
    OR              reduce using rule 20 (expressionB -> FALSE .)
    VAREND          reduce using rule 20 (expressionB -> FALSE .)
    INTDECL         reduce using rule 20 (expressionB -> FALSE .)
    BOOLDECL        reduce using rule 20 (expressionB -> FALSE .)
    RPAREN          reduce using rule 20 (expressionB -> FALSE .)


state 24

    (23) expressionB -> NOT . LPAREN expressionB RPAREN

    LPAREN          shift and go to state 34


state 25

    (24) expressionB -> LPAREN . expressionB RPAREN
    (18) factorI -> LPAREN . expressionI RPAREN
    (19) expressionB -> . TRUE
    (20) expressionB -> . FALSE
    (21) expressionB -> . expressionB AND expressionB
    (22) expressionB -> . expressionB OR expressionB
    (23) expressionB -> . NOT LPAREN expressionB RPAREN
    (24) expressionB -> . LPAREN expressionB RPAREN
    (25) expressionB -> . expressionI LT expressionI
    (26) expressionB -> . expressionI LE expressionI
    (27) expressionB -> . expressionI GT expressionI
    (28) expressionB -> . expressionI GE expressionI
    (29) expressionB -> . expressionI EQ expressionI
    (30) expressionB -> . expressionI NEQ expressionI
    (10) expressionI -> . expressionI PLUS termI
    (11) expressionI -> . expressionI MINUS termI
    (12) expressionI -> . termI
    (13) termI -> . termI TIMES factorI
    (14) termI -> . termI DIVIDE factorI
    (15) termI -> . factorI
    (16) factorI -> . INTEGER
    (17) factorI -> . NAME
    (18) factorI -> . LPAREN expressionI RPAREN

    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24
    LPAREN          shift and go to state 25
    INTEGER         shift and go to state 19
    NAME            shift and go to state 15

    expressionB                    shift and go to state 35
    expressionI                    shift and go to state 36
    termI                          shift and go to state 17
    factorI                        shift and go to state 18

state 26

    (25) expressionB -> expressionI . LT expressionI
    (26) expressionB -> expressionI . LE expressionI
    (27) expressionB -> expressionI . GT expressionI
    (28) expressionB -> expressionI . GE expressionI
    (29) expressionB -> expressionI . EQ expressionI
    (30) expressionB -> expressionI . NEQ expressionI
    (10) expressionI -> expressionI . PLUS termI
    (11) expressionI -> expressionI . MINUS termI

    LT              shift and go to state 37
    LE              shift and go to state 38
    GT              shift and go to state 39
    GE              shift and go to state 40
    EQ              shift and go to state 41
    NEQ             shift and go to state 42
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28


state 27

    (10) expressionI -> expressionI PLUS . termI
    (13) termI -> . termI TIMES factorI
    (14) termI -> . termI DIVIDE factorI
    (15) termI -> . factorI
    (16) factorI -> . INTEGER
    (17) factorI -> . NAME
    (18) factorI -> . LPAREN expressionI RPAREN

    INTEGER         shift and go to state 19
    NAME            shift and go to state 15
    LPAREN          shift and go to state 20

    termI                          shift and go to state 43
    factorI                        shift and go to state 18

state 28

    (11) expressionI -> expressionI MINUS . termI
    (13) termI -> . termI TIMES factorI
    (14) termI -> . termI DIVIDE factorI
    (15) termI -> . factorI
    (16) factorI -> . INTEGER
    (17) factorI -> . NAME
    (18) factorI -> . LPAREN expressionI RPAREN

    INTEGER         shift and go to state 19
    NAME            shift and go to state 15
    LPAREN          shift and go to state 20

    termI                          shift and go to state 44
    factorI                        shift and go to state 18

state 29

    (13) termI -> termI TIMES . factorI
    (16) factorI -> . INTEGER
    (17) factorI -> . NAME
    (18) factorI -> . LPAREN expressionI RPAREN

    INTEGER         shift and go to state 19
    NAME            shift and go to state 15
    LPAREN          shift and go to state 20

    factorI                        shift and go to state 45

state 30

    (14) termI -> termI DIVIDE . factorI
    (16) factorI -> . INTEGER
    (17) factorI -> . NAME
    (18) factorI -> . LPAREN expressionI RPAREN

    INTEGER         shift and go to state 19
    NAME            shift and go to state 15
    LPAREN          shift and go to state 20

    factorI                        shift and go to state 46

state 31

    (18) factorI -> LPAREN expressionI . RPAREN
    (10) expressionI -> expressionI . PLUS termI
    (11) expressionI -> expressionI . MINUS termI

    RPAREN          shift and go to state 47
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28


state 32

    (21) expressionB -> expressionB AND . expressionB
    (19) expressionB -> . TRUE
    (20) expressionB -> . FALSE
    (21) expressionB -> . expressionB AND expressionB
    (22) expressionB -> . expressionB OR expressionB
    (23) expressionB -> . NOT LPAREN expressionB RPAREN
    (24) expressionB -> . LPAREN expressionB RPAREN
    (25) expressionB -> . expressionI LT expressionI
    (26) expressionB -> . expressionI LE expressionI
    (27) expressionB -> . expressionI GT expressionI
    (28) expressionB -> . expressionI GE expressionI
    (29) expressionB -> . expressionI EQ expressionI
    (30) expressionB -> . expressionI NEQ expressionI
    (10) expressionI -> . expressionI PLUS termI
    (11) expressionI -> . expressionI MINUS termI
    (12) expressionI -> . termI
    (13) termI -> . termI TIMES factorI
    (14) termI -> . termI DIVIDE factorI
    (15) termI -> . factorI
    (16) factorI -> . INTEGER
    (17) factorI -> . NAME
    (18) factorI -> . LPAREN expressionI RPAREN

    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24
    LPAREN          shift and go to state 25
    INTEGER         shift and go to state 19
    NAME            shift and go to state 15

    expressionB                    shift and go to state 48
    expressionI                    shift and go to state 26
    termI                          shift and go to state 17
    factorI                        shift and go to state 18

state 33

    (22) expressionB -> expressionB OR . expressionB
    (19) expressionB -> . TRUE
    (20) expressionB -> . FALSE
    (21) expressionB -> . expressionB AND expressionB
    (22) expressionB -> . expressionB OR expressionB
    (23) expressionB -> . NOT LPAREN expressionB RPAREN
    (24) expressionB -> . LPAREN expressionB RPAREN
    (25) expressionB -> . expressionI LT expressionI
    (26) expressionB -> . expressionI LE expressionI
    (27) expressionB -> . expressionI GT expressionI
    (28) expressionB -> . expressionI GE expressionI
    (29) expressionB -> . expressionI EQ expressionI
    (30) expressionB -> . expressionI NEQ expressionI
    (10) expressionI -> . expressionI PLUS termI
    (11) expressionI -> . expressionI MINUS termI
    (12) expressionI -> . termI
    (13) termI -> . termI TIMES factorI
    (14) termI -> . termI DIVIDE factorI
    (15) termI -> . factorI
    (16) factorI -> . INTEGER
    (17) factorI -> . NAME
    (18) factorI -> . LPAREN expressionI RPAREN

    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24
    LPAREN          shift and go to state 25
    INTEGER         shift and go to state 19
    NAME            shift and go to state 15

    expressionB                    shift and go to state 49
    expressionI                    shift and go to state 26
    termI                          shift and go to state 17
    factorI                        shift and go to state 18

state 34

    (23) expressionB -> NOT LPAREN . expressionB RPAREN
    (19) expressionB -> . TRUE
    (20) expressionB -> . FALSE
    (21) expressionB -> . expressionB AND expressionB
    (22) expressionB -> . expressionB OR expressionB
    (23) expressionB -> . NOT LPAREN expressionB RPAREN
    (24) expressionB -> . LPAREN expressionB RPAREN
    (25) expressionB -> . expressionI LT expressionI
    (26) expressionB -> . expressionI LE expressionI
    (27) expressionB -> . expressionI GT expressionI
    (28) expressionB -> . expressionI GE expressionI
    (29) expressionB -> . expressionI EQ expressionI
    (30) expressionB -> . expressionI NEQ expressionI
    (10) expressionI -> . expressionI PLUS termI
    (11) expressionI -> . expressionI MINUS termI
    (12) expressionI -> . termI
    (13) termI -> . termI TIMES factorI
    (14) termI -> . termI DIVIDE factorI
    (15) termI -> . factorI
    (16) factorI -> . INTEGER
    (17) factorI -> . NAME
    (18) factorI -> . LPAREN expressionI RPAREN

    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    NOT             shift and go to state 24
    LPAREN          shift and go to state 25
    INTEGER         shift and go to state 19
    NAME            shift and go to state 15

    expressionB                    shift and go to state 50
    expressionI                    shift and go to state 26
    termI                          shift and go to state 17
    factorI                        shift and go to state 18

state 35

    (24) expressionB -> LPAREN expressionB . RPAREN
    (21) expressionB -> expressionB . AND expressionB
    (22) expressionB -> expressionB . OR expressionB

    RPAREN          shift and go to state 51
    AND             shift and go to state 32
    OR              shift and go to state 33


state 36

    (18) factorI -> LPAREN expressionI . RPAREN
    (25) expressionB -> expressionI . LT expressionI
    (26) expressionB -> expressionI . LE expressionI
    (27) expressionB -> expressionI . GT expressionI
    (28) expressionB -> expressionI . GE expressionI
    (29) expressionB -> expressionI . EQ expressionI
    (30) expressionB -> expressionI . NEQ expressionI
    (10) expressionI -> expressionI . PLUS termI
    (11) expressionI -> expressionI . MINUS termI

    RPAREN          shift and go to state 47
    LT              shift and go to state 37
    LE              shift and go to state 38
    GT              shift and go to state 39
    GE              shift and go to state 40
    EQ              shift and go to state 41
    NEQ             shift and go to state 42
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28


state 37

    (25) expressionB -> expressionI LT . expressionI
    (10) expressionI -> . expressionI PLUS termI
    (11) expressionI -> . expressionI MINUS termI
    (12) expressionI -> . termI
    (13) termI -> . termI TIMES factorI
    (14) termI -> . termI DIVIDE factorI
    (15) termI -> . factorI
    (16) factorI -> . INTEGER
    (17) factorI -> . NAME
    (18) factorI -> . LPAREN expressionI RPAREN

    INTEGER         shift and go to state 19
    NAME            shift and go to state 15
    LPAREN          shift and go to state 20

    expressionI                    shift and go to state 52
    termI                          shift and go to state 17
    factorI                        shift and go to state 18

state 38

    (26) expressionB -> expressionI LE . expressionI
    (10) expressionI -> . expressionI PLUS termI
    (11) expressionI -> . expressionI MINUS termI
    (12) expressionI -> . termI
    (13) termI -> . termI TIMES factorI
    (14) termI -> . termI DIVIDE factorI
    (15) termI -> . factorI
    (16) factorI -> . INTEGER
    (17) factorI -> . NAME
    (18) factorI -> . LPAREN expressionI RPAREN

    INTEGER         shift and go to state 19
    NAME            shift and go to state 15
    LPAREN          shift and go to state 20

    expressionI                    shift and go to state 53
    termI                          shift and go to state 17
    factorI                        shift and go to state 18

state 39

    (27) expressionB -> expressionI GT . expressionI
    (10) expressionI -> . expressionI PLUS termI
    (11) expressionI -> . expressionI MINUS termI
    (12) expressionI -> . termI
    (13) termI -> . termI TIMES factorI
    (14) termI -> . termI DIVIDE factorI
    (15) termI -> . factorI
    (16) factorI -> . INTEGER
    (17) factorI -> . NAME
    (18) factorI -> . LPAREN expressionI RPAREN

    INTEGER         shift and go to state 19
    NAME            shift and go to state 15
    LPAREN          shift and go to state 20

    expressionI                    shift and go to state 54
    termI                          shift and go to state 17
    factorI                        shift and go to state 18

state 40

    (28) expressionB -> expressionI GE . expressionI
    (10) expressionI -> . expressionI PLUS termI
    (11) expressionI -> . expressionI MINUS termI
    (12) expressionI -> . termI
    (13) termI -> . termI TIMES factorI
    (14) termI -> . termI DIVIDE factorI
    (15) termI -> . factorI
    (16) factorI -> . INTEGER
    (17) factorI -> . NAME
    (18) factorI -> . LPAREN expressionI RPAREN

    INTEGER         shift and go to state 19
    NAME            shift and go to state 15
    LPAREN          shift and go to state 20

    expressionI                    shift and go to state 55
    termI                          shift and go to state 17
    factorI                        shift and go to state 18

state 41

    (29) expressionB -> expressionI EQ . expressionI
    (10) expressionI -> . expressionI PLUS termI
    (11) expressionI -> . expressionI MINUS termI
    (12) expressionI -> . termI
    (13) termI -> . termI TIMES factorI
    (14) termI -> . termI DIVIDE factorI
    (15) termI -> . factorI
    (16) factorI -> . INTEGER
    (17) factorI -> . NAME
    (18) factorI -> . LPAREN expressionI RPAREN

    INTEGER         shift and go to state 19
    NAME            shift and go to state 15
    LPAREN          shift and go to state 20

    expressionI                    shift and go to state 56
    termI                          shift and go to state 17
    factorI                        shift and go to state 18

state 42

    (30) expressionB -> expressionI NEQ . expressionI
    (10) expressionI -> . expressionI PLUS termI
    (11) expressionI -> . expressionI MINUS termI
    (12) expressionI -> . termI
    (13) termI -> . termI TIMES factorI
    (14) termI -> . termI DIVIDE factorI
    (15) termI -> . factorI
    (16) factorI -> . INTEGER
    (17) factorI -> . NAME
    (18) factorI -> . LPAREN expressionI RPAREN

    INTEGER         shift and go to state 19
    NAME            shift and go to state 15
    LPAREN          shift and go to state 20

    expressionI                    shift and go to state 57
    termI                          shift and go to state 17
    factorI                        shift and go to state 18

state 43

    (10) expressionI -> expressionI PLUS termI .
    (13) termI -> termI . TIMES factorI
    (14) termI -> termI . DIVIDE factorI

    PLUS            reduce using rule 10 (expressionI -> expressionI PLUS termI .)
    MINUS           reduce using rule 10 (expressionI -> expressionI PLUS termI .)
    VAREND          reduce using rule 10 (expressionI -> expressionI PLUS termI .)
    INTDECL         reduce using rule 10 (expressionI -> expressionI PLUS termI .)
    BOOLDECL        reduce using rule 10 (expressionI -> expressionI PLUS termI .)
    LT              reduce using rule 10 (expressionI -> expressionI PLUS termI .)
    LE              reduce using rule 10 (expressionI -> expressionI PLUS termI .)
    GT              reduce using rule 10 (expressionI -> expressionI PLUS termI .)
    GE              reduce using rule 10 (expressionI -> expressionI PLUS termI .)
    EQ              reduce using rule 10 (expressionI -> expressionI PLUS termI .)
    NEQ             reduce using rule 10 (expressionI -> expressionI PLUS termI .)
    RPAREN          reduce using rule 10 (expressionI -> expressionI PLUS termI .)
    AND             reduce using rule 10 (expressionI -> expressionI PLUS termI .)
    OR              reduce using rule 10 (expressionI -> expressionI PLUS termI .)
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30


state 44

    (11) expressionI -> expressionI MINUS termI .
    (13) termI -> termI . TIMES factorI
    (14) termI -> termI . DIVIDE factorI

    PLUS            reduce using rule 11 (expressionI -> expressionI MINUS termI .)
    MINUS           reduce using rule 11 (expressionI -> expressionI MINUS termI .)
    VAREND          reduce using rule 11 (expressionI -> expressionI MINUS termI .)
    INTDECL         reduce using rule 11 (expressionI -> expressionI MINUS termI .)
    BOOLDECL        reduce using rule 11 (expressionI -> expressionI MINUS termI .)
    LT              reduce using rule 11 (expressionI -> expressionI MINUS termI .)
    LE              reduce using rule 11 (expressionI -> expressionI MINUS termI .)
    GT              reduce using rule 11 (expressionI -> expressionI MINUS termI .)
    GE              reduce using rule 11 (expressionI -> expressionI MINUS termI .)
    EQ              reduce using rule 11 (expressionI -> expressionI MINUS termI .)
    NEQ             reduce using rule 11 (expressionI -> expressionI MINUS termI .)
    RPAREN          reduce using rule 11 (expressionI -> expressionI MINUS termI .)
    AND             reduce using rule 11 (expressionI -> expressionI MINUS termI .)
    OR              reduce using rule 11 (expressionI -> expressionI MINUS termI .)
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30


state 45

    (13) termI -> termI TIMES factorI .

    TIMES           reduce using rule 13 (termI -> termI TIMES factorI .)
    DIVIDE          reduce using rule 13 (termI -> termI TIMES factorI .)
    PLUS            reduce using rule 13 (termI -> termI TIMES factorI .)
    MINUS           reduce using rule 13 (termI -> termI TIMES factorI .)
    VAREND          reduce using rule 13 (termI -> termI TIMES factorI .)
    INTDECL         reduce using rule 13 (termI -> termI TIMES factorI .)
    BOOLDECL        reduce using rule 13 (termI -> termI TIMES factorI .)
    LT              reduce using rule 13 (termI -> termI TIMES factorI .)
    LE              reduce using rule 13 (termI -> termI TIMES factorI .)
    GT              reduce using rule 13 (termI -> termI TIMES factorI .)
    GE              reduce using rule 13 (termI -> termI TIMES factorI .)
    EQ              reduce using rule 13 (termI -> termI TIMES factorI .)
    NEQ             reduce using rule 13 (termI -> termI TIMES factorI .)
    RPAREN          reduce using rule 13 (termI -> termI TIMES factorI .)
    AND             reduce using rule 13 (termI -> termI TIMES factorI .)
    OR              reduce using rule 13 (termI -> termI TIMES factorI .)


state 46

    (14) termI -> termI DIVIDE factorI .

    TIMES           reduce using rule 14 (termI -> termI DIVIDE factorI .)
    DIVIDE          reduce using rule 14 (termI -> termI DIVIDE factorI .)
    PLUS            reduce using rule 14 (termI -> termI DIVIDE factorI .)
    MINUS           reduce using rule 14 (termI -> termI DIVIDE factorI .)
    VAREND          reduce using rule 14 (termI -> termI DIVIDE factorI .)
    INTDECL         reduce using rule 14 (termI -> termI DIVIDE factorI .)
    BOOLDECL        reduce using rule 14 (termI -> termI DIVIDE factorI .)
    LT              reduce using rule 14 (termI -> termI DIVIDE factorI .)
    LE              reduce using rule 14 (termI -> termI DIVIDE factorI .)
    GT              reduce using rule 14 (termI -> termI DIVIDE factorI .)
    GE              reduce using rule 14 (termI -> termI DIVIDE factorI .)
    EQ              reduce using rule 14 (termI -> termI DIVIDE factorI .)
    NEQ             reduce using rule 14 (termI -> termI DIVIDE factorI .)
    RPAREN          reduce using rule 14 (termI -> termI DIVIDE factorI .)
    AND             reduce using rule 14 (termI -> termI DIVIDE factorI .)
    OR              reduce using rule 14 (termI -> termI DIVIDE factorI .)


state 47

    (18) factorI -> LPAREN expressionI RPAREN .

    TIMES           reduce using rule 18 (factorI -> LPAREN expressionI RPAREN .)
    DIVIDE          reduce using rule 18 (factorI -> LPAREN expressionI RPAREN .)
    PLUS            reduce using rule 18 (factorI -> LPAREN expressionI RPAREN .)
    MINUS           reduce using rule 18 (factorI -> LPAREN expressionI RPAREN .)
    VAREND          reduce using rule 18 (factorI -> LPAREN expressionI RPAREN .)
    INTDECL         reduce using rule 18 (factorI -> LPAREN expressionI RPAREN .)
    BOOLDECL        reduce using rule 18 (factorI -> LPAREN expressionI RPAREN .)
    LT              reduce using rule 18 (factorI -> LPAREN expressionI RPAREN .)
    LE              reduce using rule 18 (factorI -> LPAREN expressionI RPAREN .)
    GT              reduce using rule 18 (factorI -> LPAREN expressionI RPAREN .)
    GE              reduce using rule 18 (factorI -> LPAREN expressionI RPAREN .)
    EQ              reduce using rule 18 (factorI -> LPAREN expressionI RPAREN .)
    NEQ             reduce using rule 18 (factorI -> LPAREN expressionI RPAREN .)
    RPAREN          reduce using rule 18 (factorI -> LPAREN expressionI RPAREN .)
    AND             reduce using rule 18 (factorI -> LPAREN expressionI RPAREN .)
    OR              reduce using rule 18 (factorI -> LPAREN expressionI RPAREN .)


state 48

    (21) expressionB -> expressionB AND expressionB .
    (21) expressionB -> expressionB . AND expressionB
    (22) expressionB -> expressionB . OR expressionB

    AND             reduce using rule 21 (expressionB -> expressionB AND expressionB .)
    VAREND          reduce using rule 21 (expressionB -> expressionB AND expressionB .)
    INTDECL         reduce using rule 21 (expressionB -> expressionB AND expressionB .)
    BOOLDECL        reduce using rule 21 (expressionB -> expressionB AND expressionB .)
    RPAREN          reduce using rule 21 (expressionB -> expressionB AND expressionB .)
    OR              shift and go to state 33

  ! OR              [ reduce using rule 21 (expressionB -> expressionB AND expressionB .) ]
  ! AND             [ shift and go to state 32 ]


state 49

    (22) expressionB -> expressionB OR expressionB .
    (21) expressionB -> expressionB . AND expressionB
    (22) expressionB -> expressionB . OR expressionB

    AND             reduce using rule 22 (expressionB -> expressionB OR expressionB .)
    OR              reduce using rule 22 (expressionB -> expressionB OR expressionB .)
    VAREND          reduce using rule 22 (expressionB -> expressionB OR expressionB .)
    INTDECL         reduce using rule 22 (expressionB -> expressionB OR expressionB .)
    BOOLDECL        reduce using rule 22 (expressionB -> expressionB OR expressionB .)
    RPAREN          reduce using rule 22 (expressionB -> expressionB OR expressionB .)

  ! AND             [ shift and go to state 32 ]
  ! OR              [ shift and go to state 33 ]


state 50

    (23) expressionB -> NOT LPAREN expressionB . RPAREN
    (21) expressionB -> expressionB . AND expressionB
    (22) expressionB -> expressionB . OR expressionB

    RPAREN          shift and go to state 58
    AND             shift and go to state 32
    OR              shift and go to state 33


state 51

    (24) expressionB -> LPAREN expressionB RPAREN .

    AND             reduce using rule 24 (expressionB -> LPAREN expressionB RPAREN .)
    OR              reduce using rule 24 (expressionB -> LPAREN expressionB RPAREN .)
    VAREND          reduce using rule 24 (expressionB -> LPAREN expressionB RPAREN .)
    INTDECL         reduce using rule 24 (expressionB -> LPAREN expressionB RPAREN .)
    BOOLDECL        reduce using rule 24 (expressionB -> LPAREN expressionB RPAREN .)
    RPAREN          reduce using rule 24 (expressionB -> LPAREN expressionB RPAREN .)


state 52

    (25) expressionB -> expressionI LT expressionI .
    (10) expressionI -> expressionI . PLUS termI
    (11) expressionI -> expressionI . MINUS termI

    AND             reduce using rule 25 (expressionB -> expressionI LT expressionI .)
    OR              reduce using rule 25 (expressionB -> expressionI LT expressionI .)
    VAREND          reduce using rule 25 (expressionB -> expressionI LT expressionI .)
    INTDECL         reduce using rule 25 (expressionB -> expressionI LT expressionI .)
    BOOLDECL        reduce using rule 25 (expressionB -> expressionI LT expressionI .)
    RPAREN          reduce using rule 25 (expressionB -> expressionI LT expressionI .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28


state 53

    (26) expressionB -> expressionI LE expressionI .
    (10) expressionI -> expressionI . PLUS termI
    (11) expressionI -> expressionI . MINUS termI

    AND             reduce using rule 26 (expressionB -> expressionI LE expressionI .)
    OR              reduce using rule 26 (expressionB -> expressionI LE expressionI .)
    VAREND          reduce using rule 26 (expressionB -> expressionI LE expressionI .)
    INTDECL         reduce using rule 26 (expressionB -> expressionI LE expressionI .)
    BOOLDECL        reduce using rule 26 (expressionB -> expressionI LE expressionI .)
    RPAREN          reduce using rule 26 (expressionB -> expressionI LE expressionI .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28


state 54

    (27) expressionB -> expressionI GT expressionI .
    (10) expressionI -> expressionI . PLUS termI
    (11) expressionI -> expressionI . MINUS termI

    AND             reduce using rule 27 (expressionB -> expressionI GT expressionI .)
    OR              reduce using rule 27 (expressionB -> expressionI GT expressionI .)
    VAREND          reduce using rule 27 (expressionB -> expressionI GT expressionI .)
    INTDECL         reduce using rule 27 (expressionB -> expressionI GT expressionI .)
    BOOLDECL        reduce using rule 27 (expressionB -> expressionI GT expressionI .)
    RPAREN          reduce using rule 27 (expressionB -> expressionI GT expressionI .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28


state 55

    (28) expressionB -> expressionI GE expressionI .
    (10) expressionI -> expressionI . PLUS termI
    (11) expressionI -> expressionI . MINUS termI

    AND             reduce using rule 28 (expressionB -> expressionI GE expressionI .)
    OR              reduce using rule 28 (expressionB -> expressionI GE expressionI .)
    VAREND          reduce using rule 28 (expressionB -> expressionI GE expressionI .)
    INTDECL         reduce using rule 28 (expressionB -> expressionI GE expressionI .)
    BOOLDECL        reduce using rule 28 (expressionB -> expressionI GE expressionI .)
    RPAREN          reduce using rule 28 (expressionB -> expressionI GE expressionI .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28


state 56

    (29) expressionB -> expressionI EQ expressionI .
    (10) expressionI -> expressionI . PLUS termI
    (11) expressionI -> expressionI . MINUS termI

    AND             reduce using rule 29 (expressionB -> expressionI EQ expressionI .)
    OR              reduce using rule 29 (expressionB -> expressionI EQ expressionI .)
    VAREND          reduce using rule 29 (expressionB -> expressionI EQ expressionI .)
    INTDECL         reduce using rule 29 (expressionB -> expressionI EQ expressionI .)
    BOOLDECL        reduce using rule 29 (expressionB -> expressionI EQ expressionI .)
    RPAREN          reduce using rule 29 (expressionB -> expressionI EQ expressionI .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28


state 57

    (30) expressionB -> expressionI NEQ expressionI .
    (10) expressionI -> expressionI . PLUS termI
    (11) expressionI -> expressionI . MINUS termI

    AND             reduce using rule 30 (expressionB -> expressionI NEQ expressionI .)
    OR              reduce using rule 30 (expressionB -> expressionI NEQ expressionI .)
    VAREND          reduce using rule 30 (expressionB -> expressionI NEQ expressionI .)
    INTDECL         reduce using rule 30 (expressionB -> expressionI NEQ expressionI .)
    BOOLDECL        reduce using rule 30 (expressionB -> expressionI NEQ expressionI .)
    RPAREN          reduce using rule 30 (expressionB -> expressionI NEQ expressionI .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28


state 58

    (23) expressionB -> NOT LPAREN expressionB RPAREN .

    AND             reduce using rule 23 (expressionB -> NOT LPAREN expressionB RPAREN .)
    OR              reduce using rule 23 (expressionB -> NOT LPAREN expressionB RPAREN .)
    VAREND          reduce using rule 23 (expressionB -> NOT LPAREN expressionB RPAREN .)
    INTDECL         reduce using rule 23 (expressionB -> NOT LPAREN expressionB RPAREN .)
    BOOLDECL        reduce using rule 23 (expressionB -> NOT LPAREN expressionB RPAREN .)
    RPAREN          reduce using rule 23 (expressionB -> NOT LPAREN expressionB RPAREN .)

